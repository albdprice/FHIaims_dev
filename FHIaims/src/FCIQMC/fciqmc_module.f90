module fciqmc_module

!  PURPOSE
!
!  This file may at some point contain all the needed variable declarations and
!  subroutines for the FCIQMC and conventional FCI calculations
!
!
!  AUTHOR
!    FHI-aims team, Fritz-Haber Institute of the Max-Planck-Society
!  SEE ALSO
!    Volker Blum, Ralf Gehrke, Felix Hanke, Paula Havu, Ville Havu,
!    Xinguo Ren, Karsten Reuter and Matthias Scheffler,
!    "Ab initio simulations with Numeric Atom-Centered Orbitals: FHI-aims",
!    Computer Physics Communications (2008), submitted.
!  COPYRIGHT
!   Max-Planck-Gesellschaft zur Foerderung der Wissenschaften
!   e.V. Please note that any use of the "FHI-aims-Software" is subject to
!   the terms and conditions of the respective license agreement."
!  HISTORY
!    Release version, FHI-aims (2008).
!    This file was written by Jan Kloppenburg
!  SOURCE

  use dimensions
  use runtime_choices
  use physics
  use species_data
  use constants
  use gw_para
  use grids
  use geometry
  use mpi_utilities
  use synchronize_mpi
  use sbt_overlap_aims
  use localorb_io
  use basis
  use prodbas
  use grids
  use hartree_fock
  use timing
  use mpi_tasks
  use mpi_utilities
  use timing

  implicit none
  ! integral_4ks : four-index integrals (ij|kl)
  ! In new version, it is generated by ovlp_3ks on-the-fly
  real*8, dimension(:,:,:,:,:,:), allocatable :: integral_4ks
  complex*16, dimension(:,:,:,:,:,:), allocatable :: integral_4ks_complex
  ! thee-center integrals (P|ij)
  real*8, dimension(:,:,:,:), allocatable :: ovlp_3ks
  ! integral_2ks : two-index integrals (i|T+V_{ext}|j)
  real*8, dimension(:,:,:), allocatable :: integral_2ks
  complex*16, dimension(:,:,:), allocatable :: integral_2ks_complex
  ! occ_num_0 : electron occupation of the HF ground state
  integer, dimension(:,:), allocatable :: occ_num_0
  ! n_elec : the electron number in alpha and beta spaces
  integer, dimension(2) :: n_elec
  ! n_configuration : the configuration number in CI calculations
  integer :: n_configuration
  ! n_configuration_1a : the configuration number in CI calculations
  !                      with one-electron exciation in the alpha spin space
  ! n_configuration_1b : the configuration number in CI calculations
  !                      with one-electron exciation in the beta spin space
  integer :: n_configuration_1a, n_configuration_1b
  ! n_configuration_1a1b : the configuration number in CI calculations
  !                      with two-electron exciation in both spin spaces
  ! n_configuration_2a : the configuration number in CI calculations
  !                      with two-electron exciation in the alpha spin space
  ! n_configuration_2b : the configuration number in CI calculations
  !                      with two-electron exciation in the beta spin space
  integer :: n_configuration_1a1b, n_configuration_2a, n_configuration_2b
  ! n_configuration_vector : 1: 0
  !                          2: 1 + n_configuration_1a
  !                          3: 2 + n_configuration_1b
  !                          4: 3 + n_configuration_1a1b
  !                          5: 4 + n_configuration_2a
  integer :: n_configuration_vector(5)
  ! E_HF    : the expectation energies of each hamiltonian
  ! E_corr : the correlation energy calculated by the CI method
  real*8 :: E_HF, E_corr
  ! flag_not_initialization : set .true. (default) to calculate the normal c_vector
  !                               .false. to calculate the first c_vector
  logical :: flag_not_initialization = .true.

  ! c_vect : the parameter vector of configuration without the parameter of E_HF
  ! c_0    : The CI coefficient of the HF ground state configuration
  ! norm_A : the normalization constant for c_vect
  real*8 :: c_0, norm_A
  real*8, dimension(:), allocatable :: c_vect

  ! V_00   : -0.5d0*\sum_ij(ii||jj)
  ! E_ci   : The CI electron total energy
  ! w_0    : the w number for the ground state
  real*8 :: V_00, E_ci, w_0
  real*8, dimension(:), allocatable :: w_vect

  ! i_start_ci : the starting index of the valence states
  integer :: i_start_ci

  ! Threshold for generating the FCIDUMP file
  real*8  :: Threshold_Int = 1.0d-10

  ! For seeking the index of configurations
  integer :: n_vir_states(2)
  integer :: n_occ_states(2)
  integer :: n_double_vir_states(2)
  integer :: n_double_occ_states(2)

  ! For the memory distribution: memory_table
  ! 3 X 2 X 5 X n_tasks, where :
  !                        5 represents 1a, 1b, 1a1a, 2a and 2b respectively
  !                        2 represents global and local indices
  !                        3 represents the starting, ending indices and configuration numbers in this thresh
  integer, allocatable, dimension(:,:,:,:) :: memory_table
  integer, allocatable, dimension(:) :: n_configuration_table
  integer :: n_configuration_thresh
  ! For the index distribution: index_table
  ! 4 X 5 X n_tasks, where 5 represents 1a, 1b, 1a1a, 2a and 2b respectively
  !                        4 represents the starting index for occupied and virtual orbitals
  !                         for 1a:   index_table(1,:) for the starting occupied orbital in the alpha space
  !                                   index_table(2,:) for the starting virtual orbital in the alpha space
  !                         for 1b:   index_table(1,:) for the starting occupied orbital in the beta space
  !                                   index_table(2,:) for the starting virtual orbital in the beta space
  !                         for 1a1b: index_table(1,:) for the starting occupied orbital in the alpha space
  !                                   index_table(2,:) for the starting virtual orbital in the alpha space
  !                                   index_table(3,:) for the starting occupied orbital in the beta space
  !                                   index_table(4,:) for the starting virtual orbital in the beta space
  !                         for 2a:   index_table(1,:) for the starting 1st occupied orbital in the alpha space
  !                                   index_table(2,:) for the starting 1st virtual orbital in the alpha space
  !                                   index_table(3,:) for the starting 2nd occupied orbital in the alpha space
  !                                   index_table(4,:) for the starting 2nd virtual orbital in the alpha space
  !                         for 2b:   index_table(1,:) for the starting 1st occupied orbital in the beta space
  !                                   index_table(2,:) for the starting 1st virtual orbital in the beta space
  !                                   index_table(3,:) for the starting 2nd occupied orbital in the beta space
  !                                   index_table(4,:) for the starting 2nd virtual orbital in the beta space
  integer, allocatable, dimension(:,:,:) :: index_table

! Variables used in acceleration procedure(Pople's version or RLE scheme)
! Array for storage of CI-SCF wave functions (c_vectors)
  Double precision , allocatable , dimension(:,:) :: ci_acc_save_cvect
  Double precision , allocatable , dimension(:) :: ci_acc_save_c0

! Array for storage of w=HC (w_vectors)
  Double precision , allocatable , dimension(:,:) :: ci_acc_save_wvect
  Double precision , allocatable , dimension(:) :: ci_acc_save_w0

! Array for storage of eigen values of Fock opperator (Es)
  Double precision , allocatable , dimension(:) :: ci_acc_Es

! Diagonal matrix D in RLE scheme
  Double precision , allocatable , dimension(:) :: ci_rle_diag

! Diagonal matrix Hd in Davidson's method
  Double precision , allocatable , dimension(:) :: ci_acc_Hdiag

! Hamiltonian matrix in the subspace consist of trial wave-functions
  Double precision , dimension(:,:) , allocatable :: ci_acc_H_matrix

! Overlap matrix in Pople's version
  Double precision , dimension(:,:) , allocatable :: ci_acc_ovlp_matrix

! dimension of ci_acc_H_matrix and ci_acc_ovlp_matrix
  Integer :: n_dim_ci_acc_matrix    ! n_dim_ci_acc_matrix <= n_ci_acc_save

! Start point of ci_acc_save_cvect
  Integer :: ci_acc_start                   

! End point of ci_acc_save_cvect
  Integer :: ci_acc_end                     

! Location of saving new basis vector
  Integer :: loc_ci_acc_save

  contains

subroutine ci_initialization()
    implicit none
    ! temp variables
    integer :: errnum
    integer :: i_state, i_spin
    if (myid .eq. 0) then
        write(use_unit,'(2X,A)') &
            "| Prepare the two-index and four-index integrals for CI"
    endif

    ! initialize the occupation number of the HF ground state
    if (.not.allocated(occ_num_0)) then
        allocate(occ_num_0(n_states,2), stat=errnum)
        call check_allocation(errnum, 'occ_num_0 in CI')
    endif
    if (n_spin.eq.1) then
        do i_state = 1, n_states, 1
            if (abs(occ_numbers(i_state,1,1)).le.1d-6 ) then
              occ_num_0(i_state,1) = 0
              occ_num_0(i_state,2) = 0
            else
                if (abs(occ_numbers(i_state,1,1)-2.0d0).le.1d-6) then
                    occ_num_0(i_state,1) = 1
                    occ_num_0(i_state,2) = 1
                elseif (abs(occ_numbers(i_state,1,1)-1.0d0).le.1d-6) then
                    occ_num_0(i_state,1) = 1
                    occ_num_0(i_state,2) = 0
                endif
            endif
        enddo
    else
        do i_spin = 1, n_spin, 1
          do i_state = 1, n_states, 1
            if( occ_numbers(i_state,i_spin,1).le.1d-6 ) then
                occ_num_0(i_state,i_spin) = 0
            elseif (abs(occ_numbers(i_state,1,1)-1.0d0).le.1d-6) then
                occ_num_0(i_state,i_spin) = 1
            endif
          enddo
        enddo
        !call aims_stop('************   Spin UNrestricted calculations are not yet possible!')
    endif
    !determine the alpha and beta electron numbers
    n_elec = 0
    do i_spin = 1, 2, 1
      do i_state = 1, n_states, 1
        if (occ_num_0(i_state,i_spin).eq.1) then
            n_elec(i_spin) = n_elec(i_spin)+1
        endif
      enddo
    enddo


    ! get 3-index integrals (p|kl)
    if (use_2d_corr) then
        call aims_stop(&
            'CI scheme is not implemented currently together with 2D memory distribution')
        !ndim1_o3KS = (n_states-1)/np1_o3KS + 1
        !ndim2_o3KS = (n_states-1)/np2_o3KS + 1
        !write(use_unit,*) ndim1_o3KS, ndim2_o3KS, np1_o3KS, np2_o3KS
        if (allocated(ovlp_3ks)) then
            deallocate(ovlp_3ks)
        endif
        !allocate(ovlp_3KS(n_basbas,ndim1_o3KS,ndim2_o3KS,n_spin),stat=errnum)
        !call check_allocation(errnum, 'ovlp_3ks (2D) in CI')
        call get_ovlp_3ks_2d()
    else
        if (allocated(ovlp_3ks)) then
            deallocate(ovlp_3ks)
        endif
        !allocate(ovlp_3ks(n_basbas,n_states,n_states,n_spin), stat=errnum)
        !call check_allocation(errnum, 'ovlp_3ks (1D) in CI')
        call get_ovlp_3ks_1d()

    endif

    ! determine the lowest valence state in the frozen-core algorithrm
    if (flag_frozen_core_postSCF) then
        call count_frozen_core_states(i_start_ci)
        if(myid.eq.0) then
           write(use_unit,'(2X,A,I8)') &
               "| Frozen core number      ::", &
               i_start_ci - 1
        endif
    else
        i_start_ci = 1
    endif

    ! determin the number of virtual states
    do i_spin = 1, 2, 1
      n_vir_states(i_spin) = n_states - n_elec(i_spin)
      n_occ_states(i_spin) = n_elec(i_spin) - i_start_ci + 1
      n_double_vir_states(i_spin) = n_vir_states(i_spin)*(n_vir_states(i_spin)-1)/2
      n_double_occ_states(i_spin) = n_occ_states(i_spin)*(n_occ_states(i_spin)-1)/2
    enddo
    if (myid .eq. 0) then
        write(use_unit,'(2X,A)') 'Counting the numbers of different states'
        write(use_unit,'(2X,A,2I8,A,2I8)') &
            '| n_occ_states :', n_occ_states(:), &
            '; n_double_occ_states :', n_double_occ_states(:)
        write(use_unit,'(2X,A,2I8,A,2I8)') &
            '| n_vir_states :', n_vir_states(:), &
            '; n_double_vir_states :', n_double_vir_states(:)
    endif

    ! get 2-index integrals (i|T+V_{ext}|k)
    if (.not.allocated(integral_2ks)) then
        allocate(integral_2ks(n_states,n_states,n_spin), stat=errnum)
        call check_allocation(errnum, 'integrals_2ks (1D) in CI')
    endif
!    call get_2_index_integrals_1d(integral_2ks)

    call evaluate_exact_exchange_1d(ovlp_3ks)

    ! calculate the HF ground state energy
!    call evaluate_eigenvalue_configuration(occ_num_0,V_00)
!    call evaluate_Hamiltonian_matrix_element(occ_num_0,occ_num_0,E_HF)
!    V_00 = E_HF-V_00

!    Call ci_evaluate_V00(occ_num_0,V_00)
!    Call evaluate_eigenvalue_configuration(occ_num_0,E_HF)

!    if (myid.eq.0) then
!      write(use_unit,*) 'Sum of eigenvalues',E_HF
!    end if

!    E_HF = E_HF + V_00

    call evaluate_eigenvalue_configuration(occ_num_0,V_00)
    E_HF = total_energy - en_ion_ion
    V_00 = E_HF - V_00

    if (myid .eq. 0) then
        write(use_unit,'(2X,A,F16.8,A)') &
            "| HF ground state         ::", E_HF+en_ion_ion, &
            ' Hartree'
!        write(use_unit,*) 'V_00',V_00
!        write(use_unit,*) 'total_energy',total_energy
    endif

    ! now deallocate the memory about the taburated grids.
    call deallocate_grid_storage()
    ! now deallocate the memory about the auxiliary basis sets
    call cleanup_basbas()
    ! now deallocate the momory related to hartree_fock.mod
    call cleanup_hartree_fock()

    ! initialization of CI accelaration method
    if ((ci_acc_method.gt.0).and.(ci_acc_method.le.3)) then

      ! Pople's acceleration method or RLE method
      if (.not.allocated(ci_acc_save_c0)) then
        allocate(ci_acc_save_c0(n_ci_acc_save), stat=errnum)
        call check_allocation(errnum, 'ci_acc_save_c0 in CI')
      end if

      if (.not.allocated(ci_acc_H_matrix)) then
        allocate(ci_acc_H_matrix(n_ci_acc_save,n_ci_acc_save),stat=errnum)
        call check_allocation(errnum, 'ci_acc_H_matrix in CI')
        ci_acc_H_matrix=0.0D0
      end if

    end if

    if ((ci_acc_method.eq.2).or.(ci_acc_method.eq.3)) then

      ! Pople's acceleration method
      if (.not.allocated(ci_acc_save_w0)) then
        allocate(ci_acc_save_w0(n_ci_acc_save), stat=errnum)
        call check_allocation(errnum, 'ci_acc_save_w0 in CI')
      end if

      if (.not.allocated(ci_acc_ovlp_matrix)) then
        allocate(ci_acc_ovlp_matrix(n_ci_acc_save,n_ci_acc_save), stat=errnum)
        call check_allocation(errnum, 'ci_acc_ovlp_matrix in CI')
        ci_acc_ovlp_matrix=0.0D0
      end if 

    end if


end subroutine ci_initialization

subroutine parallel_initialization()
    implicit none
    integer :: i_task, i_conf,iiii
    integer :: tmp_length(5), tmp_end(5)
    integer :: errnum, info
    character*128 :: info_str


    if (.not.allocated(memory_table)) then
        allocate(memory_table(3,2,5,n_tasks), stat=errnum)
        call check_allocation(errnum, 'memory_table in CI')
    endif
    if (.not.allocated(index_table)) then
        allocate(index_table(4,5,n_tasks), stat=errnum)
        call check_allocation(errnum, 'index_table in CI')
    endif
    if (.not.allocated(n_configuration_table)) then
        allocate(n_configuration_table(n_tasks), stat=errnum)
        call check_allocation(errnum, 'n_configuration_table in CI')
    endif

    memory_table = 0
    index_table  = 0
    n_configuration_table = 0

    if (n_tasks .eq. 1) then
        tmp_length(1) = n_configuration_1a
        tmp_length(2) = n_configuration_1b
        tmp_length(3) = n_configuration_1a1b
        tmp_length(4) = n_configuration_2a
        tmp_length(5) = n_configuration_2b

        tmp_end(1) = n_configuration_1a
        tmp_end(2) = tmp_end(1) + n_configuration_1b
        tmp_end(3) = tmp_end(2) + n_configuration_1a1b
        tmp_end(4) = tmp_end(3) + n_configuration_2a
        tmp_end(5) = tmp_end(4) + n_configuration_2b
    else
        do i_conf = 1, 5, 1
          tmp_end(i_conf) = n_configuration_vector(i_conf)
        enddo
        if (myid .eq. (n_tasks-1)) then
            tmp_length(1) = mod(n_configuration_1a, n_tasks-1)
            tmp_end(1)    = tmp_end(1) + n_configuration_1a
            tmp_length(2) = mod(n_configuration_1b, n_tasks-1)
            tmp_end(2)    = tmp_end(2) + n_configuration_1b
            tmp_length(3) = mod(n_configuration_1a1b, n_tasks-1)
            tmp_end(3)    = tmp_end(3) + n_configuration_1a1b
            tmp_length(4) = mod(n_configuration_2a, n_tasks-1)
            tmp_end(4)    = tmp_end(4) + n_configuration_2a
            tmp_length(5) = mod(n_configuration_2b, n_tasks-1)
            tmp_end(5)    = tmp_end(5) + n_configuration_2b
        else
            tmp_length(1) = n_configuration_1a/(n_tasks-1)
            tmp_end(1)    = tmp_end(1) + tmp_length(1) * (myid + 1)
            tmp_length(2) = n_configuration_1b/(n_tasks-1)
            tmp_end(2)    = tmp_end(2) + tmp_length(2) * (myid + 1)
            tmp_length(3) = n_configuration_1a1b/(n_tasks-1)
            tmp_end(3)    = tmp_end(3) + tmp_length(3) * (myid + 1)
            tmp_length(4) = n_configuration_2a/(n_tasks-1)
            tmp_end(4)    = tmp_end(4) + tmp_length(4) * (myid + 1)
            tmp_length(5) = n_configuration_2b/(n_tasks-1)
            tmp_end(5)    = tmp_end(5) + tmp_length(5) * (myid + 1)
        endif
    endif

    ! at first, for the global index
    do i_conf = 1, 5, 1
      ! the configuration number for each type of excitations
      memory_table(3,1,i_conf,myid+1) = tmp_length(i_conf)
      memory_table(3,2,i_conf,myid+1) = tmp_length(i_conf)
      ! the index of the ending configuration
      memory_table(2,1,i_conf,myid+1) = tmp_end(i_conf)
      ! the index of the starting configuration
      memory_table(1,1,i_conf,myid+1) = tmp_end(i_conf) - tmp_length(i_conf) + 1
      !n_configuration_thresh = n_configuration_thresh + memory_table(3,i_conf)
      n_configuration_table(myid+1) = n_configuration_table(myid+1) + &
          memory_table(3,1,i_conf,myid+1)

      !if (myid .eq. (n_tasks-1) .and. memory_table(3,1,i_conf,n_tasks) .eq. 0) then
      if (memory_table(3,1,i_conf,myid+1) .eq. 0) then
          ! initialize the index_table based on the end configuration
!          call reverse_seek_index(&
!              memory_table(2,1,i_conf,myid+1),&
!              index_table(:,i_conf,myid+1),&
!              i_conf)
          ! force to make the starting index bigger than the end index
!          memory_table(1,1,i_conf,n_tasks) = memory_table(2,1,i_conf,n_tasks) + 1

        index_table(1,i_conf,myid+1)=n_states+1
        index_table(2,i_conf,myid+1)=n_states
        index_table(3,i_conf,myid+1)=n_states+1
        index_table(4,i_conf,myid+1)=n_states

      else
          call reverse_seek_index(&
              memory_table(1,1,i_conf,myid+1),&
              index_table(:,i_conf,myid+1),&
              i_conf)
      endif

    enddo

    !then, for the local index
    do i_conf = 1, 5, 1
      memory_table(2,2,i_conf,myid+1) = sum(memory_table(3,1,1:i_conf,myid+1))
      memory_table(1,2,i_conf,myid+1) = &
          memory_table(2,2,i_conf,myid+1) - memory_table(3,2,i_conf,myid+1) + 1
    enddo

    ! debug
    !write(use_unit,*) myid, memory_table(3,:,myid+1)

    call sync_integer_vector(memory_table, 3*2*5*n_tasks)

    call sync_integer_vector(index_table, 4*5*n_tasks)

    call sync_integer_vector(n_configuration_table, n_tasks)

    if (myid .eq. 0) then
        write(use_unit,'(2X,A)') &
            "| Memory distribution in parallel"
        write(use_unit,'(2X,A,6A8)') &
            "| Config. Index global      :", "1a","1b","1a1b","2a","2b","Total" 
        do i_task = 1, n_tasks, 1
          write(use_unit,'(2X,A,I5,A,6I8)') &
              "| For thresh ", i_task-1," start    :", memory_table(1,1,:,i_task), &
              n_configuration_table(i_task)
          write(use_unit,'(2X,A,5I8)') &
              "|                  end      :", memory_table(2,1,:,i_task)
        enddo
        write(use_unit,'(2X,A,6A8)') &
            "| Config. Index local       :", "1a","1b","1a1b","2a","2b","Total" 
        do i_task = 1, n_tasks, 1
          write(use_unit,'(2X,A,I5,A,6I8)') &
              "| For thresh ", i_task-1," start    :", memory_table(1,2,:,i_task), &
              n_configuration_table(i_task)
          write(use_unit,'(2X,A,5I8)') &
              "|                  end      :", memory_table(2,2,:,i_task)
        enddo


        !write(use_unit,'(2X,A)') &
        !    "| Corresponding orbital indices"
        write(use_unit,'(2X,A,5A8)') &
             "| Starting Index            :", "1a","1b","1a1b","2a","2b"
        do i_task = 1, n_tasks, 1
          write(use_unit,'(2X,A,I5,A,5I8)') &
              "| For thresh ", i_task-1," 1st occ. :", index_table(1,:,i_task)
          write(use_unit,'(2X,A,5I8)') &
              "|                  1st vir. :", index_table(2,:,i_task)
          write(use_unit,'(2X,A,3I8)') &
              "|                  2nd occ. :                ",&
              index_table(3,3:5,i_task)
          write(use_unit,'(2X,A,3I8)') &
              "|                  2nd vir. :                ",&
              index_table(4,3:5,i_task)
        enddo
    endif

    n_configuration_thresh = n_configuration_table(myid+1)

    if (.not.allocated(c_vect)) then
        allocate(c_vect(n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'c_vect in CI')
    endif
    if (.not.allocated(w_vect)) then
        allocate(w_vect(n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'w_vect in CI')
    endif

    if ((ci_acc_method.le.3).and.(ci_acc_method.ne.0)) then

      ! Pople's method or RLE scheme
      if (.not.allocated(ci_acc_save_cvect)) then
        allocate(ci_acc_save_cvect(n_ci_acc_save,n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'ci_acc_save_cvect in CI')
      end if

      if (.not.allocated(ci_acc_Es)) then
        allocate(ci_acc_Es(n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'ci_acc_Es in CI')
        ci_acc_Es = 0.0D0
        Call initialize_ci_acc_Es()
        if (myid.eq.0) then
          write(use_unit,*) ' End of initialization of ci_acc_Es'
        end if
      end if

    end if

    if ((ci_acc_method.eq.2).or.(ci_acc_method.eq.3)) then
      ! Pople's method
      if (.not.allocated(ci_acc_save_wvect)) then
        allocate(ci_acc_save_wvect(n_ci_acc_save,n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'ci_acc_save_wvect in CI')
      end if
   end if

   if (ci_acc_method.eq.3) then
      if (.not.allocated(ci_acc_Hdiag)) then
        allocate(ci_acc_Hdiag(n_configuration_table(myid+1)), stat=errnum)
        call check_allocation(errnum, 'ci_acc_Hdiag in CI')
      end if
      call initialize_ci_acc_Hdiag()
      if (myid.eq.0) then
        write(use_unit,*) 'End of initialization of ci_acc_Hdiag'
      end if
   end if

    if (ci_acc_method.eq.1) then

      ! RLE scheme
      if (.not.allocated(ci_rle_diag)) then
        allocate(ci_rle_diag(n_configuration_table(myid+1)),stat=errnum)
        call check_allocation(errnum, 'ci_rle_diag in CI')
      end if

    end if

    if (myid.eq.0) then
      write(use_unit,*) 'ci_acc_method',ci_acc_method
    end if

end subroutine parallel_initialization


subroutine get_ovlp_3ks_1d()
    ! prepare ovlp_3ks
    ! Igor Ying Zhang 2013-07-28
    implicit none

    integer :: n_bytes_o3KS, i_basbas
    integer :: i_spin, i_state, j_state

    character*128 :: info_str
    integer :: errnum

    real*8, allocatable, dimension(:,:,:,:) :: ovlp_3ks_local

    allocate(ovlp_3ks_local(n_loc_prodbas,n_states,n_states,n_spin), stat=errnum)
    call check_allocation(errnum, 'ovlp_3ks_local (1D) in CI')

    if (myid.eq.0) then
      write(use_unit,*) 'n_loc_prodbas',n_loc_prodbas
      write(use_unit,*) 'n_states',n_states
      write(use_unit,*) 'n_basis',n_basis
      write(use_unit,*) 'n_basbas',n_basbas
    end if


    if (sparse_o3fn) then
    ! coeff_3fn_ten, coulomb_matr_lvl -> ovlp_3KS
      call aims_stop('no sparse implementation for CI yet!')
    else
    ! coeff_3fn -> ovlp_3KS
      call transform_ovlp3fn(n_states, ks_eigenvector, ovlp_3fn, ovlp_3ks_local)
    end if

    !write(use_unit,*) "just debug"
    !write(use_unit,*) map_prodbas(:,myid+1) 

    write(info_str,'(2X,A,I5,A,I5,A,I5)') &
        'n_loc_prodbas for the thresh ',myid, ' is ', n_loc_prodbas, &
        ' with the starting index of ',map_prodbas(1,myid+1)
    call localorb_allinfo(info_str, use_unit, '(A)', OL_norm)

    deallocate(ovlp_3fn)

    ! now broadcast ovlp_3ks to be grobal
    n_bytes_o3KS = 8d0 * n_basbas * n_states * n_states * n_spin
    write(info_str, "(2X,A,I7,A,I7,A,F12.3,A)") &
    & 'The ovlp_3KS matrix takes ', nint(n_bytes_o3KS / 2.d0**20), &
    & ' MB x', n_tasks, ' procs =', n_tasks * n_bytes_o3KS / 2.d0**30, ' GB.'
    call localorb_info(info_str, use_unit, '(A)', OL_norm)

    allocate(ovlp_3ks(n_basbas,n_states,n_states,n_spin), stat=errnum)
    call check_allocation(errnum, 'ovlp_3ks (1D) in CI')

    ovlp_3ks = 0.0d0
    do i_spin = 1, n_spin, 1
      do i_state = 1, n_states, 1
        do j_state = 1, n_states, 1
          do i_basbas = 1, n_loc_prodbas, 1
            ovlp_3ks(map_prodbas(i_basbas,myid+1),j_state,i_state,i_spin) = &
                ovlp_3ks_local(i_basbas,j_state,i_state,i_spin)
          enddo
        enddo
      enddo
    enddo

    deallocate(ovlp_3ks_local)
    deallocate(map_prodbas)

    call sync_vector(ovlp_3ks, n_basbas*n_states*n_states*n_spin)

end subroutine get_ovlp_3ks_1d

subroutine get_ovlp_3ks_2d()
    implicit none

    integer :: errnum

    character*128 :: info_str

    real*8  :: n_bytes_o3KS
    real*8, allocatable, dimension(:,:) :: ovlp_3fn

    allocate(ovlp_3fn(n_basis_pairs,n_loc_prodbas), stat=errnum)
    call check_allocation(errnum,'ovlp_3fn (2D) for CI')

    call get_coeff_3fn_v_2d(ovlp_3fn)

    call get_timestamps(time_ovlp3fn_to_ovlp3KS, clock_time_ovlp3fn_to_ovlp3KS)

    ndim1_o3KS = (n_states-1)/np1_o3KS + 1
    ndim2_o3KS = (n_states-1)/np2_o3KS + 1

    call localorb_info('|', use_unit, '(2x,A)', OL_norm)
    n_bytes_o3KS = 8d0 * n_basbas * ndim1_o3KS * ndim2_o3KS * n_spin
    write(info_str, "(2X,A,I7,A,I7,A,F12.3,A)") &
    & '| The ovlp_3KS matrix takes another', nint(n_bytes_o3KS / 2.d0**20), &
    & ' MB x', n_tasks, ' procs =', n_tasks * n_bytes_o3KS / 2.d0**30, ' GB.'
    call localorb_info(info_str, use_unit, '(A)', OL_norm)
    call localorb_info('|', use_unit, '(2x,A)', OL_norm)

    if (sparse_o3fn) then
    ! coeff_3fn_ten, coulomb_matr_lvl -> ovlp_3KS
      !call ovlp3KS_lvl_2d(n_states, KS_eigenvector, &
      !                  coeff_3fn_ten, coulomb_matr_lvl, ovlp_3KS)
      call aims_stop('No sparse in CI routines yet')
    else
      call transform_ovlp3fn_2(n_states,KS_eigenvector,ovlp_3fn,ovlp_3ks)
    end if

    deallocate(ovlp_3fn)
end subroutine get_ovlp_3ks_2d

subroutine get_4_index_integrals_1d(integral_4ks)
    ! prepare 4-index integrals (ij|kl)
    ! Igor Ying Zhang 2013-06-12
    implicit none
    real*8, dimension(:,:,:,:,:,:), intent(out) :: integral_4ks
    
    real*8, allocatable, dimension(:,:,:,:) :: ovlp_3ks
    !real*8, allocatable, dimension(:,:) :: ovlp_3fn

    real*8  :: ddot
    ! temp variables
    integer :: errnum
    integer :: i_state, j_state, k_state, l_state, i_spin, j_spin
    integer :: i_aux


    integral_4ks = 0.0d0

    if (.not.allocated(ovlp_3ks)) then
        allocate(ovlp_3ks(n_basbas,n_states,n_states,n_spin), stat=errnum)
        call check_allocation(errnum, 'ovlp_3ks (1D) in FCIQMC')
    endif

    if (sparse_o3fn) then
    ! coeff_3fn_ten, coulomb_matr_lvl -> ovlp_3KS
      call aims_stop('no sparse implementation for CI yet!')
    else
    ! coeff_3fn -> ovlp_3KS
      call transform_ovlp3fn(n_states, ks_eigenvector, ovlp_3fn, ovlp_3ks)
    end if
    !deallocate(ovlp_3fn)
    
    if (n_spin==1) then
        do i_state = 1, n_states, 1
          do j_state = 1, n_states, 1
            do k_state = 1, n_states, 1
              do l_state = 1, n_states, 1
                integral_4ks(l_state,k_state,1,j_state,i_state,1) = &
                    ddot(n_basbas, &
                    ovlp_3ks(:,l_state,k_state,1),1, &
                    ovlp_3ks(:,j_state,i_state,1),1)
              enddo
            enddo
          enddo
        enddo
    else
        do i_spin = 1, n_spin, 1
          do i_state = 1, n_states, 1
            do j_state = 1, n_states, 1
              do j_spin = 1, n_spin, 1
                do k_state = 1, n_states, 1
                  do l_state = 1, n_states, 1
                    integral_4ks(l_state,k_state,j_spin,j_state,i_state,i_spin) = &
                        ddot(n_basbas, &
                        ovlp_3ks(:,l_state,k_state,j_spin),1, &
                        ovlp_3ks(:,j_state,i_state,i_spin),1)
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
       !call aims_stop('************   Spin UNrestricted calculations are not yet possible!')
    endif
    deallocate(ovlp_3ks)
end subroutine get_4_index_integrals_1d

subroutine get_2_index_integrals_1d(integral_2ks)
    ! get 2-index integrals. (i|T+V_{ext}|k)
    ! Expectation values of kinetic operator and electron-nulei interation operator
    ! Igor Ying Zhang 2013-06-12
    implicit none
    real*8, dimension(:,:,:), intent(out) :: integral_2ks
    
    !real*8  :: ddot
    ! temp variables
    integer :: errnum, occ_states, unocc_states
    integer :: i_state, j_state, k_state, l_state
    integer :: i_spin, j_spin
    integer :: info
    real*8, dimension(:,:), allocatable :: tmp_matrix
    real*8  :: T_Vext, Vhartree, E_noXC
    real*8  :: ddot

    !------------------------------------------------------------
    ! calculate the hamiltonian matrix with only hatree potential
    !------------------------------------------------------------
    ! calculate the matrix of (i|T+V_{ext}+V_{Hartree}|j)
    flag_xc               = 0
    hybrid_coeff          = 0.0d0
    flag_turn_off_hartree = .true.
    integral_2ks(:,:,:)   = 0.d0

    call integrate_real_hamiltonian_matrix_p2 &
       ( hartree_potential,   rho, rho_gradient, partition_tab, l_shell_max, &
       en_xc, en_pot_xc, hamiltonian )

    call mpi_barrier(mpi_comm_global,info)


    if(n_spin==1) then
      ! transfer the hamiltonian in the Kohn-Sham orbital representation
      do i_state = 1, n_states, 1
        do j_state = 1, i_state, 1
            integral_2ks(j_state,i_state,1) = &
                hamiltonian(j_state + ((i_state-1)*i_state)/2,1)
        enddo
      enddo
      if (.not.allocated(tmp_matrix)) then
          allocate(tmp_matrix(n_basis,n_basis), stat=errnum)
          call check_allocation(errnum, 'tmp_matrix (1D) in FCIQMC')
      endif
      tmp_matrix(:,:) = 0.d0
      call dsymm('L', 'U', n_basis, &
                 n_states, 1.0d0, &
                 integral_2ks(:,:,1), n_basis, &
                 KS_eigenvector(:,:,1,1), &
                 n_basis, 0.d0, &
                 tmp_matrix, &
                 n_basis &
                 )

      integral_2ks(:,:,1) = 0.d0
      call dgemm('T', 'N', n_states, &
                  n_states, n_basis, 1.0d0, &
                  tmp_matrix, &
                  n_basis, &
                  KS_eigenvector(:,:,1,1), &
                  n_basis, 0.d0, &
                  integral_2ks(:,:,1), &
                  n_states &
                  )
      deallocate(tmp_matrix)
      ! eliminate the electron-electron hatree contribution from the
      ! hamiltonian
      ! first, count the occ_states
      occ_states = 0
      unocc_states = 0
      do i_state=1, n_states, 1
        if( occ_numbers(i_state,1,1).le.1d-6 ) then
          unocc_states = unocc_states + 1
        else
          occ_states = occ_states + 1
        endif
      enddo
      T_Vext = 0.d0
      Vhartree = 0.d0
      do i_state=1, occ_states, 1
          T_Vext = T_Vext + integral_2ks(i_state,i_state,1)
          do j_state=1, occ_states, 1
            Vhartree = Vhartree + &
                ddot(n_basbas, &
                ovlp_3ks(:,j_state,j_state,1),1, &
                ovlp_3ks(:,i_state,i_state,1),1)
        enddo
      enddo
      if (myid .eq. 0) then
          write(use_unit,'(2X,A,f16.8)')              "| T+Vext                  ::",&
              T_Vext*2.0d0
          write(use_unit,'(2X,A,f16.8)')              "| V_hartree               ::",&
              Vhartree*2.0d0
          write(use_unit,'(2X,A,f16.8)')              "| E_ion_ion               ::",&
              en_ion_ion
          write(use_unit,'(2X,A,f16.8,f16.8,f16.8)')  "| V_hartree_default       ::",&
              hartree_energy_free,hartree_delta_energy,&
              0.5d0*(hartree_energy_free+hartree_delta_energy)
      endif
    ! Now for n_spin == 2
    else
      ! transfer the hamiltonian in the Kohn-Sham orbital representation
      if (.not.allocated(tmp_matrix)) then
          allocate(tmp_matrix(n_basis,n_basis), stat=errnum)
          call check_allocation(errnum, 'tmp_matrix (1D) in FCIQMC')
      endif


      do i_spin = 1, n_spin, 1
        tmp_matrix(:,:) = 0.d0
        do i_state = 1, n_basis, 1
          do j_state = 1, i_state, 1
              integral_2ks(j_state,i_state,i_spin) = &
                  hamiltonian(j_state + ((i_state-1)*i_state)/2,i_spin)
          enddo
        enddo


        call dsymm('L', 'U', n_basis, &
                   n_states, 1.0d0, &
                   integral_2ks(:,:,i_spin), n_basis, &
                   KS_eigenvector(:,:,i_spin,1), &
                   n_basis, 0.d0, &
                   tmp_matrix, &
                   n_basis &
                   )

        integral_2ks(:,:,i_spin) = 0.d0
        call dgemm('T', 'N', n_states, &
                    n_states, n_basis, 1.0d0, &
                    tmp_matrix, &
                    n_basis, &
                    KS_eigenvector(:,:,i_spin,1), &
                    n_basis, 0.d0, &
                    integral_2ks(:,:,i_spin), &
                    n_states &
                    )



      enddo
      deallocate(tmp_matrix)


      T_Vext = 0.d0
      Vhartree = 0.d0
      do i_spin = 1, n_spin, 1
        do i_state=1, n_elec(i_spin), 1
          T_Vext = T_Vext + integral_2ks(i_state,i_state,i_spin)
          do j_spin = 1, n_spin, 1
            do j_state=1, n_elec(j_spin), 1
              Vhartree = Vhartree + ddot(n_basbas, &
                  ovlp_3ks(:,j_state,j_state,j_spin),1, &
                  ovlp_3ks(:,i_state,i_state,i_spin),1)
            enddo
          enddo
        enddo
      enddo


      if (myid .eq. 0) then
          write(use_unit,'(2X,A,f16.8)')              "| T+Vext                 ::",&
              T_Vext
          write(use_unit,'(2X,A,f16.8)')              "| V_hartree              ::",&
              Vhartree*0.5d0
          write(use_unit,'(2X,A,f16.8)')              "| E_ion_ion              ::",&
              en_ion_ion
          write(use_unit,'(2X,A,f16.8,f16.8,f16.8)')  "| V_hartree_default      ::",&
              hartree_energy_free,hartree_delta_energy,&
              0.5d0*(hartree_energy_free+hartree_delta_energy)
      endif
       !call aims_stop('************   Spin UNrestricted calculations are not yet possible!')
    endif
end subroutine get_2_index_integrals_1d

subroutine evaluate_exact_exchange_1d(ovlp_3ks)
    ! just for benchmark test
    implicit none
    real*8, dimension(:,:,:,:), intent(in) :: ovlp_3ks 
    real*8 :: ddot

    ! temp variables
    !integer :: occ_states, unocc_states
    integer :: i_state, j_state
    integer :: i_spin, j_spin
    real*8  :: exact_exchange_igor = 0.0d0
    
    !occ_states = 0
    !unocc_states = 0
    if(n_spin==1) then
      do i_state = 1, n_elec(1), 1
        do j_state = 1, n_elec(1), 1
          exact_exchange_igor = &
              exact_exchange_igor + &
                  ddot(n_basbas, &
                  ovlp_3ks(:,i_state,j_state,1),1, &
                  ovlp_3ks(:,i_state,j_state,1),1)
        enddo
      enddo
      exact_exchange_igor = - exact_exchange_igor
    else
      ! the orbitals with different spins does not contribute
      ! to the HF exchange term
      do i_spin = 1, n_spin, 1
        do i_state = 1, n_elec(i_spin), 1
            do j_state = 1, n_elec(i_spin), 1
                exact_exchange_igor = &
                    exact_exchange_igor + &
                        ddot(n_basbas, &
                        ovlp_3ks(:,i_state,j_state,i_spin),1, &
                        ovlp_3ks(:,i_state,j_state,i_spin),1)
            enddo
        enddo
      enddo
      exact_exchange_igor = - 0.5d0*exact_exchange_igor
      !call aims_stop('************   Spin UNrestricted calculations are not yet possible!')
    endif
    if (myid .eq. 0) then
        write(use_unit,'(2X,A,f16.8)') "| HF exchange             ::", exact_exchange_igor
    endif
end subroutine evaluate_exact_exchange_1d

subroutine evaluate_Hamiltonian_matrix_element(occ_num_1,occ_num_2,H_value)
    ! calculate the expectation value between given configurations with the electron
    ! population of occ_num_1 and occ_num_2
    implicit none
    integer, dimension(n_states,2), intent(in) :: occ_num_1, occ_num_2
    real*8 :: H_value

    ! tmp values
    integer :: i_state, j_state
    integer :: i_spin, j_spin
    integer, dimension(n_states,2) :: occ_num_3
    integer :: n_substitude(2), n_occupy(2), n_excitation
    integer :: substitude(2,2), occupy(2,2)
    real*8  :: two_electron_term
    real*8  :: ddot

    H_value = 0.0d0

    ! determine which occ. orbitals are excited,
    ! and which unocc. orbitals are then occupied.
    n_excitation    = 0
    n_substitude(:) = 0
    n_occupy(:)     = 0
    substitude(:,:) = 0
    substitude(:,:) = 0
    occupy(:,:)     = 0
    do i_spin = 1, 2, 1
      do i_state = 1, n_states, 1
          occ_num_3(i_state,i_spin) = occ_num_2(i_state,i_spin)-occ_num_1(i_state,i_spin)
          if (occ_num_3(i_state,i_spin).eq.1) then
              n_occupy(i_spin) = n_occupy(i_spin) + 1
              occupy(n_occupy(i_spin),i_spin) = i_state
          elseif (occ_num_3(i_state,i_spin).eq.-1) then
              n_excitation = n_excitation + 1
              !if (n_excitation > 2) exit
              n_substitude(i_spin) = n_substitude(i_spin) + 1
              substitude(n_substitude(i_spin),i_spin) = i_state
          endif
      enddo
    enddo
    !write(use_unit,*) ' occ_num_3', occ_num_3
    !if (n_spin > 1) then
    !   call aims_stop('************   Spin polarization calculations are not possible yet in CI')
    !endif
    if ((n_occupy(1)+n_occupy(2)) .ne. (n_substitude(1)+n_substitude(2))) then
        write(use_unit,*) occ_num_1
        write(use_unit,*) occ_num_2
        write(use_unit,*) occ_num_3
        write(use_unit,*) n_occupy, n_substitude
        write(use_unit,*) occupy, substitude
        call aims_stop('************   Two configurations have different electron numbers in this CI calculation')
    endif
    if ((n_occupy(1).ne.n_substitude(1)) .or. (n_occupy(2).ne.n_substitude(2))) then
        ! The configurations with different spin state do not interact
        ! with each other
        H_value = 0.0d0
    else
        if (n_spin .eq. 1) then
          if (n_excitation > 2) then 
              ! A couple of configurations with more than 2 substitutions
              H_value = 0.0d0
          elseif (n_excitation .eq. 2) then
              ! A couple of configurations with 2 substitutions
              if (n_occupy(1).eq.2) then ! Both substitutions occur in the alpha spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(2,1),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(2,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(1,1),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !substitude(2,1),occupy(2,1),1) - &
                      !integral_4ks(substitude(1,1),occupy(2,1),1,&
                      !substitude(2,1),occupy(1,1),1)
              elseif (n_occupy(2).eq.2) then ! Both substitutions occur in the beta spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(2,2),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(2,2),1),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(1,2),1),1)
                      !integral_4ks(substitude(1,2),occupy(1,2),1,&
                      !substitude(2,2),occupy(2,2),1) - &
                      !integral_4ks(substitude(1,2),occupy(2,2),1,&
                      !substitude(2,2),occupy(1,2),1)
              elseif (n_occupy(1).eq.1) then ! one in alpha and the other one in beta
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !substitude(1,2),occupy(1,2),1)
              endif
          elseif (n_excitation .eq. 1) then
              ! A couple of configurations with one substitution
              two_electron_term = 0.0d0
              if (n_occupy(1).eq.1) then ! The substitution occurs in the alpha spin space
                  H_value = integral_2ks(substitude(1,1),occupy(1,1),1)
                  !write(use_unit,'(2X,I3,A,A,F16.8,A,I3,I3)') n_excitation, ' in alpha', &
                  !    ', one-electron value ', H_value, ' for ', substitude(1,1), &
                  !    occupy(1,1)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        two_electron_term = &
                            two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    1),1, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        occupy(1,1),1),1, &
                            ovlp_3ks(:,substitude(1,1),i_state,    1),1)
                            !integral_4ks( &
                            !i_state,i_state,1, &
                            !substitude(1,1),occupy(1,1),1&
                            !) - &
                            !integral_4ks( &
                            !i_state,occupy(1,1),1, &
                            !substitude(1,1),i_state,1&
                            !)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, alph, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        two_electron_term = &
                            two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,    i_state,        1),1, &
                            ovlp_3ks(:,occupy(1,1),substitude(1,1),1),1)
                            !integral_4ks( &
                            !i_state,i_state,1, &
                            !occupy(1,1),substitude(1,1),1&
                            !)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, beta, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                  enddo
                  H_value = H_value + two_electron_term
              elseif (n_occupy(2).eq.1) then ! The substitution occurs in the beta spin space
                  two_electron_term = 0.0d0
                  H_value = integral_2ks(occupy(1,2),substitude(1,2),1)
                  !write(use_unit,'(2X,I3,A,A,F16.8,A,I3,I3)') n_excitation, ' in beta', &
                  !    ', one-electron value ', H_value, ' for ', occupy(1,2), &
                  !    substitude(1,2)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        two_electron_term = two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),1,&
                            !i_state,i_state,1)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, alph, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        two_electron_term = two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),i_state,    1),1, &
                            ovlp_3ks(:,i_state,        occupy(1,2),1),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),1,&
                            !i_state,i_state,1) - &
                            !integral_4ks(substitude(1,2),i_state,1,&
                            !i_state,occupy(1,2),1)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, beta, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                  enddo
                  H_value = H_value + two_electron_term
              endif
          elseif (n_excitation .eq. 0) then
              !write(use_unit,*) "igor debug alpha"
              ! A couple of configurations with the same population
              !
              ! At first, the kinetic and the electron-nuclei interactions
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      H_value = H_value + integral_2ks(i_state,i_state,1)
                  endif
                enddo
              enddo

              if (myid.eq.0) then
                write(use_unit,*) 'HF kinetic energy',H_value
              end if

              ! Then, electron-electron interactions
              two_electron_term = 0.0d0
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      do j_spin = 1, 2, 1
                        ! for the same spin orbitals
                        if (i_spin .eq. j_spin) then
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,i_state,1),1, &
                                      ovlp_3ks(:,j_state,j_state,1),1) - &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,j_state,1),1, &
                                      ovlp_3ks(:,j_state,i_state,1),1)
                                      !integral_4ks(i_state,i_state,1,&
                                      !             j_state,j_state,1) - &
                                      !integral_4ks(i_state,j_state,1,&
                                      !             j_state,i_state,1)
                              endif
                            enddo
                        ! for different spin orbitals
                        else
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,i_state,1),1, &
                                      ovlp_3ks(:,j_state,j_state,1),1)
                                      !integral_4ks(i_state,i_state,1,&
                                      !             j_state,j_state,1)
                              endif
                            enddo
                        endif
                      enddo
                  endif
                enddo
              enddo
              H_value = H_value + 0.5d0*two_electron_term

              if (myid.eq.0) then
                write(use_unit,*) 'V_ee',0.5d0*two_electron_term
              end if

          endif ! for different number of substitutions
      else !if (n_spin .eq. 2) then
          if (n_excitation > 2) then 
              ! A couple of configurations with more than 2 substitutions
              H_value = 0.0d0
          elseif (n_excitation .eq. 2) then
              ! A couple of configurations with 2 substitutions
              if (n_occupy(1).eq.2) then ! Both substitutions occur in the alpha spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(2,1),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(2,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(1,1),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !             substitude(2,1),occupy(2,1),1) - &
                      !integral_4ks(substitude(1,1),occupy(2,1),1,&
                      !             substitude(2,1),occupy(1,1),1)
              elseif (n_occupy(2).eq.2) then ! Both substitutions occur in the beta spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(2,2),2),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(2,2),2),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(1,2),2),1)
                      !integral_4ks(substitude(1,2),occupy(1,2),2,&
                      !             substitude(2,2),occupy(2,2),2) - &
                      !integral_4ks(substitude(1,2),occupy(2,2),2,&
                      !             substitude(2,2),occupy(1,2),2)
              elseif (n_occupy(1).eq.1) then ! one in alpha and the other one in beta
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !             substitude(1,2),occupy(1,2),2)
              endif
          elseif (n_excitation .eq. 1) then
              ! A couple of configurations with one substitution
              if (n_occupy(1).eq.1) then ! The substitution occurs in the alpha spin space
                  H_value = integral_2ks(substitude(1,1),occupy(1,1),1)
                  do i_state = 1, n_states, 1
                    !if (occ_num_1(i_state,1).eq.1 .and. &
                    !    substitude(1,1).ne.i_state .and. &
                    !    occupy(1,1).ne.i_state) then
                    if (occ_num_1(i_state,1).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),i_state,    1),1, &
                            ovlp_3ks(:,i_state,        occupy(1,1),1),1)
                            !integral_4ks(substitude(1,1),occupy(1,1),1,&
                            !i_state,i_state,1) - &
                            !integral_4ks(substitude(1,1),i_state,1,&
                            !i_state,occupy(1,1),1)
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    2),1)
                            !integral_4ks(substitude(1,1),occupy(1,1),1,&
                            !i_state,i_state,2)
                    endif
                  enddo
              elseif (n_occupy(2).eq.1) then ! The substitution occurs in the beta spin space
                  H_value = integral_2ks(substitude(1,2),occupy(1,2),2)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    1),1,&
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1)
                            !integral_4ks(&
                            !i_state,        i_state,    1, &
                            !substitude(1,2),occupy(1,2),2  &
                            !)
                    endif
                    !if (occ_num_1(i_state,2).eq.1 .and. &
                    !    substitude(1,2).ne.i_state .and. &
                    !    occupy(1,2).ne.i_state) then
                    if (occ_num_1(i_state,2).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    2),1,&
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        occupy(1,2),2),1,&
                            ovlp_3ks(:,substitude(1,2),i_state,    2),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),2,&
                            !i_state,i_state,2) - &
                            !integral_4ks(substitude(1,2),i_state,2,&
                            !i_state,occupy(1,2),2)
                    endif
                  enddo
              endif
          elseif (n_excitation .eq. 0) then
              ! A couple of configurations with the same population
              !
              ! At first, the kinetic and the electron-nuclei interactions
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      H_value = H_value + integral_2ks(i_state,i_state,i_spin)
                  endif
                enddo
              enddo
!!!!!!!!!!!!
              ! Then, electron-electron interactions
              two_electron_term = 0.0d0
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      do j_spin = 1, 2, 1
                        ! for the same spin orbitals
                        if (i_spin .eq. j_spin) then
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,j_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,i_state,i_spin),1) - &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,i_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,j_state,i_spin),1)
                                      !integral_4ks(j_state,j_state,j_spin,&
                                      !             i_state,i_state,i_spin) - &
                                      !integral_4ks(j_state,i_state,j_spin,&
                                      !             j_state,i_state,i_spin)
                              endif
                            enddo
                        ! for different spin orbitals
                        else
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,j_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,i_state,i_spin),1)
                                      !integral_4ks(i_state,i_state,i_spin,&
                                      !             j_state,j_state,j_spin)
                              endif
                            enddo
                        endif
                      enddo
                  endif
                enddo
              enddo
              H_value = H_value + 0.5d0*two_electron_term
          endif ! for different number of substitutions
      endif !if (n_spin .eq. 2) then
    endif !if (n_occupy(1).ne.n_substitude(1)) then
end subroutine evaluate_Hamiltonian_matrix_element

subroutine evaluate_V_st(occ_num_1,occ_num_2,H_value)
    ! calculate the expectation value between given configurations with the electron
    ! population of occ_num_1 and occ_num_2
    implicit none
    integer, dimension(n_states,2), intent(in) :: occ_num_1, occ_num_2
    real*8 :: H_value

    ! tmp values
    integer :: i_state, j_state
    integer :: i_spin, j_spin
    integer, dimension(n_states,2) :: occ_num_3
    integer :: n_substitude(2), n_occupy(2), n_excitation
    integer :: substitude(2,2), occupy(2,2)
    real*8  :: two_electron_term
    real*8  :: ddot

    H_value = 0.0d0

    ! determine which occ. orbitals are excited,
    ! and which unocc. orbitals are then occupied.
    n_excitation    = 0
    n_substitude(:) = 0
    n_occupy(:)     = 0
    substitude(:,:) = 0
    substitude(:,:) = 0
    occupy(:,:)     = 0
    do i_spin = 1, 2, 1
      do i_state = 1, n_states, 1
          occ_num_3(i_state,i_spin) = occ_num_2(i_state,i_spin)-occ_num_1(i_state,i_spin)
          if (occ_num_3(i_state,i_spin).eq.1) then
              n_occupy(i_spin) = n_occupy(i_spin) + 1
              occupy(n_occupy(i_spin),i_spin) = i_state
          elseif (occ_num_3(i_state,i_spin).eq.-1) then
              n_excitation = n_excitation + 1
              !if (n_excitation > 2) exit
              n_substitude(i_spin) = n_substitude(i_spin) + 1
              substitude(n_substitude(i_spin),i_spin) = i_state
          endif
      enddo
    enddo
    !write(use_unit,*) ' occ_num_3', occ_num_3
    !if (n_spin > 1) then
    !   call aims_stop('************   Spin polarization calculations are not possible yet in CI')
    !endif
    if ((n_occupy(1)+n_occupy(2)) .ne. (n_substitude(1)+n_substitude(2))) then
        write(use_unit,*) occ_num_1
        write(use_unit,*) occ_num_2
        write(use_unit,*) occ_num_3
        write(use_unit,*) n_occupy, n_substitude
        write(use_unit,*) occupy, substitude
        call aims_stop('************   Two configurations have different electron numbers in this CI calculation')
    endif
    if ((n_occupy(1).ne.n_substitude(1)) .or. (n_occupy(2).ne.n_substitude(2))) then
        ! The configurations with different spin state do not interact
        ! with each other
        H_value = 0.0d0
    else
        if (n_spin .eq. 1) then
          if (n_excitation > 2) then 
              ! A couple of configurations with more than 2 substitutions
              H_value = 0.0d0
          elseif (n_excitation .eq. 2) then
              ! A couple of configurations with 2 substitutions
              if (n_occupy(1).eq.2) then ! Both substitutions occur in the alpha spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(2,1),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(2,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(1,1),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !substitude(2,1),occupy(2,1),1) - &
                      !integral_4ks(substitude(1,1),occupy(2,1),1,&
                      !substitude(2,1),occupy(1,1),1)
              elseif (n_occupy(2).eq.2) then ! Both substitutions occur in the beta spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(2,2),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(2,2),1),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(1,2),1),1)
                      !integral_4ks(substitude(1,2),occupy(1,2),1,&
                      !substitude(2,2),occupy(2,2),1) - &
                      !integral_4ks(substitude(1,2),occupy(2,2),1,&
                      !substitude(2,2),occupy(1,2),1)
              elseif (n_occupy(1).eq.1) then ! one in alpha and the other one in beta
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !substitude(1,2),occupy(1,2),1)
              endif
          elseif (n_excitation .eq. 1) then
              ! A couple of configurations with one substitution
              two_electron_term = 0.0d0
              if (n_occupy(1).eq.1) then ! The substitution occurs in the alpha spin space
                  !H_value = integral_2ks(substitude(1,1),occupy(1,1),1)
                  H_value = 0.0d0
                  !write(use_unit,'(2X,I3,A,A,F16.8,A,I3,I3)') n_excitation, ' in alpha', &
                  !    ', one-electron value ', H_value, ' for ', substitude(1,1), &
                  !    occupy(1,1)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        two_electron_term = &
                            two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    1),1, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        occupy(1,1),1),1, &
                            ovlp_3ks(:,substitude(1,1),i_state,    1),1)
                            !integral_4ks( &
                            !i_state,i_state,1, &
                            !substitude(1,1),occupy(1,1),1&
                            !) - &
                            !integral_4ks( &
                            !i_state,occupy(1,1),1, &
                            !substitude(1,1),i_state,1&
                            !)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, alph, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        two_electron_term = &
                            two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,    i_state,        1),1, &
                            ovlp_3ks(:,occupy(1,1),substitude(1,1),1),1)
                            !integral_4ks( &
                            !i_state,i_state,1, &
                            !occupy(1,1),substitude(1,1),1&
                            !)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, beta, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                  enddo
                  H_value = H_value + two_electron_term
              elseif (n_occupy(2).eq.1) then ! The substitution occurs in the beta spin space
                  two_electron_term = 0.0d0
                  !H_value = integral_2ks(occupy(1,2),substitude(1,2),1)
                  H_value = 0.0d0
                  !write(use_unit,'(2X,I3,A,A,F16.8,A,I3,I3)') n_excitation, ' in beta', &
                  !    ', one-electron value ', H_value, ' for ', occupy(1,2), &
                  !    substitude(1,2)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        two_electron_term = two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),1,&
                            !i_state,i_state,1)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, alph, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        two_electron_term = two_electron_term + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,2),i_state,    1),1, &
                            ovlp_3ks(:,i_state,        occupy(1,2),1),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),1,&
                            !i_state,i_state,1) - &
                            !integral_4ks(substitude(1,2),i_state,1,&
                            !i_state,occupy(1,2),1)
                        !write(use_unit,'(2X,A,I3,A,F16.8)') "two_electron_term, beta, i_state",i_state,&
                        !   ' Value', two_electron_term
                    endif
                  enddo
                  H_value = H_value + two_electron_term
              endif
          elseif (n_excitation .eq. 0) then
              !write(use_unit,*) "igor debug alpha"
              ! A couple of configurations with the same population
              !
              ! At first, the kinetic and the electron-nuclei interactions
              !do i_spin = 1, 2, 1
              !  do i_state = 1, n_states, 1
              !    if (occ_num_1(i_state,i_spin).eq.1) then
              !        H_value = H_value + integral_2ks(i_state,i_state,1)
              !    endif
              !  enddo
              !enddo
              H_value = 0.0d0
              ! Then, electron-electron interactions
              two_electron_term = 0.0d0
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      do j_spin = 1, 2, 1
                        ! for the same spin orbitals
                        if (i_spin .eq. j_spin) then
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,i_state,1),1, &
                                      ovlp_3ks(:,j_state,j_state,1),1) - &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,j_state,1),1, &
                                      ovlp_3ks(:,j_state,i_state,1),1)
                                      !integral_4ks(i_state,i_state,1,&
                                      !             j_state,j_state,1) - &
                                      !integral_4ks(i_state,j_state,1,&
                                      !             j_state,i_state,1)
                              endif
                            enddo
                        ! for different spin orbitals
                        else
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,i_state,i_state,1),1, &
                                      ovlp_3ks(:,j_state,j_state,1),1)
                                      !integral_4ks(i_state,i_state,1,&
                                      !             j_state,j_state,1)
                              endif
                            enddo
                        endif
                      enddo
                  endif
                enddo
              enddo
              H_value = H_value + 0.5d0*two_electron_term
          endif ! for different number of substitutions
      else !if (n_spin .eq. 2) then
          if (n_excitation > 2) then 
              ! A couple of configurations with more than 2 substitutions
              H_value = 0.0d0
          elseif (n_excitation .eq. 2) then
              ! A couple of configurations with 2 substitutions
              if (n_occupy(1).eq.2) then ! Both substitutions occur in the alpha spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(2,1),1),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(2,1),1),1, &
                      ovlp_3ks(:,substitude(2,1),occupy(1,1),1),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !             substitude(2,1),occupy(2,1),1) - &
                      !integral_4ks(substitude(1,1),occupy(2,1),1,&
                      !             substitude(2,1),occupy(1,1),1)
              elseif (n_occupy(2).eq.2) then ! Both substitutions occur in the beta spin space
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(2,2),2),1) - &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,2),occupy(2,2),2),1, &
                      ovlp_3ks(:,substitude(2,2),occupy(1,2),2),1)
                      !integral_4ks(substitude(1,2),occupy(1,2),2,&
                      !             substitude(2,2),occupy(2,2),2) - &
                      !integral_4ks(substitude(1,2),occupy(2,2),2,&
                      !             substitude(2,2),occupy(1,2),2)
              elseif (n_occupy(1).eq.1) then ! one in alpha and the other one in beta
                  H_value = &
                      ddot(n_basbas, &
                      ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                      ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1)
                      !integral_4ks(substitude(1,1),occupy(1,1),1,&
                      !             substitude(1,2),occupy(1,2),2)
              endif
          elseif (n_excitation .eq. 1) then
              ! A couple of configurations with one substitution
              if (n_occupy(1).eq.1) then ! The substitution occurs in the alpha spin space
                  H_value = integral_2ks(substitude(1,1),occupy(1,1),1)
                  do i_state = 1, n_states, 1
                    !if (occ_num_1(i_state,1).eq.1 .and. &
                    !    substitude(1,1).ne.i_state .and. &
                    !    occupy(1,1).ne.i_state) then
                    if (occ_num_1(i_state,1).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    1),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),i_state,    1),1, &
                            ovlp_3ks(:,i_state,        occupy(1,1),1),1)
                            !integral_4ks(substitude(1,1),occupy(1,1),1,&
                            !i_state,i_state,1) - &
                            !integral_4ks(substitude(1,1),i_state,1,&
                            !i_state,occupy(1,1),1)
                    endif
                    if (occ_num_1(i_state,2).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,substitude(1,1),occupy(1,1),1),1, &
                            ovlp_3ks(:,i_state,        i_state,    2),1)
                            !integral_4ks(substitude(1,1),occupy(1,1),1,&
                            !i_state,i_state,2)
                    endif
                  enddo
              elseif (n_occupy(2).eq.1) then ! The substitution occurs in the beta spin space
                  H_value = integral_2ks(substitude(1,2),occupy(1,2),2)
                  do i_state = 1, n_states, 1
                    if (occ_num_1(i_state,1).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    1),1,&
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1)
                            !integral_4ks(&
                            !i_state,        i_state,    1, &
                            !substitude(1,2),occupy(1,2),2  &
                            !)
                    endif
                    !if (occ_num_1(i_state,2).eq.1 .and. &
                    !    substitude(1,2).ne.i_state .and. &
                    !    occupy(1,2).ne.i_state) then
                    if (occ_num_1(i_state,2).eq.1) then
                        H_value = H_value + &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        i_state,    2),1,&
                            ovlp_3ks(:,substitude(1,2),occupy(1,2),2),1) - &
                            ddot(n_basbas, &
                            ovlp_3ks(:,i_state,        occupy(1,2),2),1,&
                            ovlp_3ks(:,substitude(1,2),i_state,    2),1)
                            !integral_4ks(substitude(1,2),occupy(1,2),2,&
                            !i_state,i_state,2) - &
                            !integral_4ks(substitude(1,2),i_state,2,&
                            !i_state,occupy(1,2),2)
                    endif
                  enddo
              endif
          elseif (n_excitation .eq. 0) then
              ! A couple of configurations with the same population
              !
              ! At first, the kinetic and the electron-nuclei interactions
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      H_value = H_value + integral_2ks(i_state,i_state,i_spin)
                  endif
                enddo
              enddo
              ! Then, electron-electron interactions
              two_electron_term = 0.0d0
              do i_spin = 1, 2, 1
                do i_state = 1, n_states, 1
                  if (occ_num_1(i_state,i_spin).eq.1) then
                      do j_spin = 1, 2, 1
                        ! for the same spin orbitals
                        if (i_spin .eq. j_spin) then
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,j_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,i_state,i_spin),1) - &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,i_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,j_state,i_spin),1)
                                      !integral_4ks(j_state,j_state,j_spin,&
                                      !             i_state,i_state,i_spin) - &
                                      !integral_4ks(j_state,i_state,j_spin,&
                                      !             j_state,i_state,i_spin)
                              endif
                            enddo
                        ! for different spin orbitals
                        else
                            do j_state = 1, n_states, 1
                              if (occ_num_1(j_state,j_spin).eq.1) then
                                  two_electron_term = two_electron_term + &
                                      ddot(n_basbas, &
                                      ovlp_3ks(:,j_state,j_state,j_spin),1,&
                                      ovlp_3ks(:,i_state,i_state,i_spin),1)
                                      !integral_4ks(i_state,i_state,i_spin,&
                                      !             j_state,j_state,j_spin)
                              endif
                            enddo
                        endif
                      enddo
                  endif
                enddo
              enddo
              H_value = H_value + 0.5d0*two_electron_term
          endif ! for different number of substitutions
      endif !if (n_spin .eq. 2) then
    endif !if (n_occupy(1).ne.n_substitude(1)) then
end subroutine evaluate_V_st

subroutine evaluate_eigenvalue_configuration(occ_num_1,e_value)
    ! calculate the expectation value between given configurations with the electron
    ! population of occ_num_1 and occ_num_2
    implicit none
    integer, dimension(n_states,2) :: occ_num_1
    real*8 :: e_value

    ! tmp values
    integer :: i_state
    integer :: i_spin

    e_value = 0.0d0
    if (n_spin .eq. 1) then
        do i_spin = 1, 2, 1
          do i_state = 1, n_states, 1
            if (occ_num_1(i_state,i_spin).eq.1) then
                e_value = e_value + KS_eigenvalue(i_state,1,1)*1.0d0
            endif
          enddo
        enddo
    else
        do i_spin = 1, 2, 1
          do i_state = 1, n_states, 1
            if (occ_num_1(i_state,i_spin).eq.1) then
                e_value = e_value + KS_eigenvalue(i_state,i_spin,1)*1.0d0
            endif
          enddo
        enddo
    endif
end subroutine evaluate_eigenvalue_configuration

subroutine normalization_vector(vect,vect_length,c_0,norm_vect,iop)
    ! Calculate the norm of "vect" : the intermidiate normalized "norm_vect"
    ! Rescale "vect" to be intermidiate normalized or normalized
    ! iop = 0 : do intermidiate normalization
    ! iop = 1 : do normalization
    implicit none
    integer :: vect_length, iop
    real*8, dimension(vect_length) :: vect
    real*8  :: norm_vect, c_0
    !tmp variable:
    integer :: i_state
    integer :: infompi
    real*8 :: ddot

    norm_vect = 0.0d0
    norm_vect = ddot(vect_length, vect(:), 1, vect(:), 1)

    call sync_real_number(norm_vect)

    norm_vect = dsqrt(norm_vect + c_0**2)

    if (iop .eq. 0) then
        do i_state = 1, vect_length, 1
            vect(i_state) = vect(i_state)/c_0
        enddo
        norm_vect = norm_vect / c_0 ! norm of the intermidiate normalization vector
        c_0       = 1.0d0
    elseif (iop .eq. 1) then
        do i_state = 1, vect_length, 1
            vect(i_state) = vect(i_state)/norm_vect
        enddo
        c_0       = c_0 / norm_vect

        norm_vect = 1.0d0 /  c_0
    endif

end subroutine normalization_vector


  Subroutine ci_coefficient_sign(substitude,occupy,state_sign,excitation_space)
! determine the sign of the coefficient of a given excitation state
! c_ijab=-c_jiab=-c_ijba=jiba

! excitation_space: 1--alpha space  2--beta space

  Implicit None

  Integer :: substitude(2,2), occupy(2,2)
  Integer :: i_state,j_state,a_state,b_state,excitation_space
  Real*8 :: state_sign

  state_sign=1.0d0

  i_state=substitude(1,excitation_space)
  j_state=substitude(2,excitation_space)
  a_state=occupy(1,excitation_space)
  b_state=occupy(2,excitation_space)

  if (i_state.gt.j_state) then 
    state_sign=-state_sign
    substitude(1,excitation_space)=j_state
    substitude(2,excitation_space)=i_state
  end if

  if (a_state.gt.b_state) then
    state_sign=-state_sign
    occupy(1,excitation_space)=b_state
    occupy(2,excitation_space)=a_state
  end if

  End Subroutine ci_coefficient_sign


subroutine seek_index_v03_5(substitude,occupy,i_ci_final,i_task_tmp)
    ! seek index for c_vect for the double excitation in beta spin space
    ! in parallel memory distribution
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, i_task_tmp

    !if (memory_table(3,2,5,1) .eq. 0) then
    !    i_task_tmp = n_tasks+1
    !    return
    !endif

    i_ci_final = ( &
        (n_occ_states(2)-1 + n_elec(2)-substitude(1,2)+1) * &
        (substitude(1,2)-i_start_ci) / 2 + &
        substitude(2,2)-substitude(1,2)-1 &
        ) * n_double_vir_states(2) + &
        (n_vir_states(2)-1 + n_states-occupy(1,2)+1) * &
        (occupy(1,2)-n_elec(2)-1) / 2 + &
        occupy(2,2)-occupy(1,2) - 1

    ! the memory length in the 0th processor is always correct
    i_task_tmp = i_ci_final / memory_table(3,1,5,1)

    i_ci_final = memory_table(1,2,5,i_task_tmp+1) + mod(i_ci_final,memory_table(3,1,5,1))

end subroutine seek_index_v03_5

subroutine seek_index_v03_4(substitude,occupy,i_ci_final,i_task_tmp)
    ! seek index for c_vect for the double excitation in alpha spin space
    ! in parallel memory distribution
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, i_task_tmp

    !if (memory_table(3,2,4,1) .eq. 0) then
    !    i_task_tmp = n_tasks+1
    !    return
    !endif

    i_ci_final = ( &
        (n_occ_states(1)-1 + n_elec(1)-substitude(1,1)+1) * &
        (substitude(1,1)-i_start_ci) / 2 + &
        substitude(2,1)-substitude(1,1)-1 &
        ) * n_double_vir_states(1) + &
        (n_vir_states(1)-1 + n_states-occupy(1,1)+1) * &
        (occupy(1,1)-n_elec(1)-1) / 2 + &
        occupy(2,1)-occupy(1,1) - 1

    ! the memory length in the 0th processor is always correct
    i_task_tmp = i_ci_final / memory_table(3,2,4,1)

    i_ci_final = memory_table(1,2,4,i_task_tmp+1) + mod(i_ci_final,memory_table(3,2,4,1))

end subroutine seek_index_v03_4

subroutine seek_index_v03_3(substitude,occupy,i_ci_final,i_task_tmp)
    ! seek index for c_vect for the double excitation in both spin spaces
    ! in parallel memory distribution
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, i_task_tmp

    i_ci_final = ( &
        (substitude(1,1)-i_start_ci)*n_vir_states(1) + &
        occupy(1,1)-n_elec(1) - 1 &
        ) * n_occ_states(2)*n_vir_states(2) + &
        (substitude(1,2)-i_start_ci)*n_vir_states(2) + &
        occupy(1,2)-n_elec(2) - 1

    ! the memory length in the 0th processor is always correct
    !if (memory_table(3,2,3,1) .eq. 0) then
    !    i_task_tmp = n_tasks+1
    !    return
    !endif
    i_task_tmp = i_ci_final / memory_table(3,2,3,1)

    i_ci_final = memory_table(1,2,3,i_task_tmp+1) + mod(i_ci_final,memory_table(3,2,3,1))

end subroutine seek_index_v03_3

subroutine seek_index_v03_2(substitude,occupy,i_ci_final,i_task_tmp)
    ! seek index for c_vect for the single excitation in the beta spin space
    ! in parallel memory distribution
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, i_task_tmp

    i_ci_final =  (substitude(1,2)-i_start_ci)*n_vir_states(2) + &
        occupy(1,2)-n_elec(2) - 1


    ! the memory length in the 0th processor is always correct
    !if (memory_table(3,2,2,1) .eq. 0) then
    !    i_task_tmp = n_tasks+1
    !    return
    !endif
    i_task_tmp = i_ci_final / memory_table(3,2,2,1)

    i_ci_final = memory_table(1,2,2,i_task_tmp+1) + mod(i_ci_final,memory_table(3,2,2,1))

end subroutine seek_index_v03_2

subroutine seek_index_v03_1(substitude,occupy,i_ci_final,i_task_tmp)
    ! seek index for c_vect for the single excitation in the alpha spin space
    ! in parallel memory distribution
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, i_task_tmp

    i_ci_final =  (substitude(1,1)-i_start_ci)*n_vir_states(1) + &
        occupy(1,1)-n_elec(1) - 1

    ! the memory length in the 0th processor is always correct
    !if (memory_table(3,2,1,1) .eq. 0) then
    !    i_task_tmp = n_tasks+1
    !    return
    !endif
    i_task_tmp = i_ci_final / memory_table(3,2,1,1)

    i_ci_final = memory_table(1,2,1,i_task_tmp+1) + mod(i_ci_final,memory_table(3,2,1,1))

end subroutine seek_index_v03_1

subroutine seek_index_v02(substitude,occupy,excitation_type,i_ci_final)
    implicit none
    integer :: substitude(2,2), occupy(2,2)
    integer :: i_ci_final, excitation_type

    if (excitation_type .eq. 1) then
        i_ci_final =  (substitude(1,1)-i_start_ci)*n_vir_states(1) + &
            occupy(1,1)-n_elec(1)
    elseif (excitation_type .eq. 2) then
        i_ci_final =  n_configuration_1a + &
            (substitude(1,2)-i_start_ci)*n_vir_states(2) + &
            occupy(1,2)-n_elec(2)
    elseif (excitation_type .eq. 3) then
        i_ci_final = n_configuration_vector(3) + & 
            ( &
            (substitude(1,1)-i_start_ci)*n_vir_states(1) + &
            occupy(1,1)-n_elec(1) - 1 &
            ) * n_occ_states(2)*n_vir_states(2) + &
            (substitude(1,2)-i_start_ci)*n_vir_states(2) + &
            occupy(1,2)-n_elec(2)
    elseif (excitation_type .eq. 4) then
        !write(use_unit,*) n_configuration_1a+n_configuration_1b+n_configuration_1a1b,substitude(:,1), occupy(:,1)
        i_ci_final = n_configuration_vector(4) + & 
            ( &
            (n_occ_states(1)-1 + n_elec(1)-substitude(1,1)+1) * &
            (substitude(1,1)-i_start_ci) / 2 + &
            substitude(2,1)-substitude(1,1)-1 &
            ) * n_double_vir_states(1) + &
            (n_vir_states(1)-1 + n_states-occupy(1,1)+1) * &
            (occupy(1,1)-n_elec(1)-1) / 2 + &
            occupy(2,1)-occupy(1,1)
    elseif (excitation_type .eq. 5) then
        !write(use_unit,*) n_configuration_1a+n_configuration_1b+n_configuration_1a1b&
        !    +n_configuration_2a,substitude(:,2), occupy(:,2)
        i_ci_final = n_configuration_vector(5) + & 
            ( &
            (n_occ_states(2)-1 + n_elec(2)-substitude(1,2)+1) * &
            (substitude(1,2)-i_start_ci) / 2 + &
            substitude(2,2)-substitude(1,2)-1 &
            ) * n_double_vir_states(2) + &
            (n_vir_states(2)-1 + n_states-occupy(1,2)+1) * &
            (occupy(1,2)-n_elec(2)-1) / 2 + &
            occupy(2,2)-occupy(1,2)
    endif
end subroutine seek_index_v02


subroutine seek_index(occ_num_1,excitation_type,i_ci_final)
    implicit none
    integer, dimension(n_states,2) :: occ_num_1
    integer :: i_ci_final, excitation_type
    integer :: i_ci

    !integer, dimension(n_configuration,2) :: occ_num_2,occ_num_3
    integer :: i_state, j_state, a_state, b_state, i_spin
    !integer :: sum_diff
    logical :: flag_exit

    flag_exit = .false.
    if (excitation_type .eq. 1) then
        i_ci = 0
        do i_state = i_start_ci, n_elec(1), 1
          !if (flag_exit) exit
          do a_state = n_elec(1)+1, n_states, 1
            i_ci = i_ci + 1
            if (occ_num_1(i_state,1) .eq. 0 .and. &
                occ_num_1(a_state,1) .eq. 1) then
                flag_exit = .true.
                !exit
                goto 666
            endif
          enddo
        enddo
    elseif (excitation_type .eq. 2) then
        i_ci = n_configuration_1a
        do i_state = i_start_ci, n_elec(2), 1
          !if (flag_exit) exit
          do a_state = n_elec(2)+1, n_states, 1
            i_ci = i_ci + 1
            if (occ_num_1(i_state,2) .eq. 0 .and. &
                occ_num_1(a_state,2) .eq. 1) then
                flag_exit = .true.
                goto 666
            endif
          enddo
        enddo
    elseif (excitation_type .eq. 3) then
        i_ci = n_configuration_1a + n_configuration_1b
        do i_state = i_start_ci, n_elec(1), 1
          !if (flag_exit) exit
          do a_state = n_elec(1)+1, n_states, 1
            !if (flag_exit) exit
            do j_state = i_start_ci, n_elec(2), 1
              !if (flag_exit) exit
              do b_state = n_elec(2)+1, n_states, 1
                  i_ci = i_ci + 1
                  if (occ_num_1(i_state,1) .eq. 0 .and. &
                      occ_num_1(j_state,2) .eq. 0 .and. &
                      occ_num_1(a_state,1) .eq. 1 .and. &
                      occ_num_1(b_state,2) .eq. 1) then
                      flag_exit = .true.
                      !exit
                      goto 666
                  endif
              enddo
            enddo
          enddo
        enddo
    elseif (excitation_type .eq. 4) then
        i_ci = n_configuration_1a + n_configuration_1b + n_configuration_1a1b
        do i_state = i_start_ci, n_elec(1), 1
          !if (flag_exit) exit
          do j_state = i_state+1, n_elec(1), 1
            !if (flag_exit) exit
            do a_state = n_elec(1)+1, n_states, 1
              !if (flag_exit) exit
              do b_state = a_state+1, n_states, 1
                  i_ci = i_ci + 1
                  if (occ_num_1(i_state,1) .eq. 0 .and. &
                      occ_num_1(j_state,1) .eq. 0 .and. &
                      occ_num_1(a_state,1) .eq. 1 .and. &
                      occ_num_1(b_state,1) .eq. 1) then
                      flag_exit = .true.
                      goto 666
                      !exit
                  endif
              enddo
            enddo
          enddo
        enddo
    elseif (excitation_type .eq. 5) then
        i_ci = n_configuration_1a + n_configuration_1b + n_configuration_1a1b &
            + n_configuration_2a
        do i_state = i_start_ci, n_elec(2), 1
          !if (flag_exit) exit
          do j_state = i_state+1, n_elec(2), 1
            !if (flag_exit) exit
            do a_state = n_elec(2)+1, n_states, 1
              !if (flag_exit) exit
              do b_state = a_state+1, n_states, 1
                  i_ci = i_ci + 1
                  if (occ_num_1(i_state,2) .eq. 0 .and. &
                      occ_num_1(j_state,2) .eq. 0 .and. &
                      occ_num_1(a_state,2) .eq. 1 .and. &
                      occ_num_1(b_state,2) .eq. 1) then
                      flag_exit = .true.
                      !exit
                      goto 666
                  endif
              enddo
            enddo
          enddo
        enddo
    endif
666 continue
    i_ci_final = i_ci
    if (.not. flag_exit) write(use_unit,'(A)') &
        "Warnning :: cannot find this configuration"
end subroutine seek_index

subroutine reverse_seek_index(i_ci_target,index_group,excitation_type)
    implicit none
    integer :: i_ci_target, excitation_type
    integer :: index_group(4)

    integer, dimension(n_states,2) :: occ_num_1
    integer :: i_state, j_state, a_state, b_state, i_spin, i_ci
    !integer :: sum_diff
    logical :: flag_exit

    flag_exit   = .false.
    index_group = 0
    if (excitation_type .eq. 1) then
        i_ci = 0
        do i_state = i_start_ci, n_elec(1), 1
          do a_state = n_elec(1)+1, n_states, 1
            i_ci = i_ci + 1
            if (i_ci .eq. i_ci_target) then
                index_group(1) = i_state
                index_group(2) = a_state
                flag_exit = .true.
                goto 666
            endif
          enddo
        enddo
    elseif (excitation_type .eq. 2) then
        i_ci = n_configuration_1a
        do i_state = i_start_ci, n_elec(2), 1
          do a_state = n_elec(2)+1, n_states, 1
            i_ci = i_ci + 1
            if (i_ci .eq. i_ci_target) then
                index_group(1) = i_state
                index_group(2) = a_state
                flag_exit = .true.
                goto 666
            endif
          enddo
        enddo
    elseif (excitation_type .eq. 3) then
        i_ci = n_configuration_1a + n_configuration_1b
        do i_state = i_start_ci, n_elec(1), 1
          do a_state = n_elec(1)+1, n_states, 1
            do j_state = i_start_ci, n_elec(2), 1
              do b_state = n_elec(2)+1, n_states, 1
                  i_ci = i_ci + 1
                  if (i_ci .eq. i_ci_target) then
                      index_group(1) = i_state
                      index_group(2) = a_state
                      index_group(3) = j_state
                      index_group(4) = b_state
                      flag_exit = .true.
                      !exit
                      goto 666
                  endif
              enddo
            enddo
          enddo
        enddo
    elseif (excitation_type .eq. 4) then
        i_ci = n_configuration_1a + n_configuration_1b + n_configuration_1a1b
        do i_state = i_start_ci, n_elec(1), 1
          do j_state = i_state+1, n_elec(1), 1
            do a_state = n_elec(1)+1, n_states, 1
              do b_state = a_state+1, n_states, 1
                  i_ci = i_ci + 1
                  if (i_ci .eq. i_ci_target) then
                      index_group(1) = i_state
                      index_group(2) = a_state
                      index_group(3) = j_state
                      index_group(4) = b_state
                      flag_exit = .true.
                      goto 666
                  endif
              enddo
            enddo
          enddo
        enddo
    elseif (excitation_type .eq. 5) then
        i_ci = n_configuration_1a + n_configuration_1b + n_configuration_1a1b &
            + n_configuration_2a
        do i_state = i_start_ci, n_elec(2), 1
          do j_state = i_state+1, n_elec(2), 1
            do a_state = n_elec(2)+1, n_states, 1
              do b_state = a_state+1, n_states, 1
                  i_ci = i_ci + 1
                  if (i_ci .eq. i_ci_target) then
                      flag_exit = .true.
                      index_group(1) = i_state
                      index_group(2) = a_state
                      index_group(3) = j_state
                      index_group(4) = b_state
                      goto 666
                  endif
              enddo
            enddo
          enddo
        enddo
    endif
666 continue
    if (.not. flag_exit) write(use_unit,'(A,3I5)') &
        "Warnning :: cannot find this configuration (reverse_seek_index)",&
        i_ci_target, excitation_type, myid
end subroutine reverse_seek_index

subroutine output_FCIDUMP_cluster_1d()

!  PURPOSE
!
!  The '''output_FCIDUMP_cluster_1d''' generate FCIDUMP file for NECI calculations
!  based on "1d" memory distribution
!
    implicit none
    ! temp variables
    integer, dimension(:,:), allocatable :: occ_num_0, occ_num_1
    ! temp indices
    integer :: i_state, j_state, k_state, l_state, i_spin, j_spin
    integer :: i_ci
    integer :: errnum, info
    integer :: unit_fci
    !character*128 :: info_str
    character(len=128) :: string_form

    real*8  :: ddot
    real*8  :: integral_4ks_tmp
    real*8, allocatable, dimension(:,:,:,:) :: ovlp_3ks_local

    ! get 2-index integrals (i|T+V_{ext}|k)
    if (.not.allocated(integral_2ks)) then
        allocate(integral_2ks(n_states,n_states,n_spin), stat=errnum)
        call check_allocation(errnum, 'integrals_2ks (1D) in CI')
    endif
    call get_2_index_integrals_1d_NECI(integral_2ks)
    ! now deallocate the memory about the taburated grids.
    call deallocate_grid_storage()

    ! get ovlp_3ks_local
    allocate(ovlp_3ks_local(n_loc_prodbas,n_states,n_states,n_spin), stat=errnum)
    call check_allocation(errnum, 'ovlp_3ks_local (1D) in CI')

    if (sparse_o3fn) then
    ! coeff_3fn_ten, coulomb_matr_lvl -> ovlp_3KS
      call aims_stop('no sparse implementation for CI yet!')
    else
    ! coeff_3fn -> ovlp_3KS
      call transform_ovlp3fn(n_states, ks_eigenvector, ovlp_3fn, ovlp_3ks_local)
    end if
    call cleanup_hartree_fock()

    ! initialize the occupation number of the HF ground state
    if (.not.allocated(occ_num_0)) then
        allocate(occ_num_0(n_states,2), stat=errnum)
        call check_allocation(errnum, 'occ_num_0 in CI')
    endif
    occ_num_0 = 0
    if (n_spin.eq.1) then
        do i_state = 1, n_states, 1
            if( occ_numbers(i_state,1,1).le.1d-6 ) then
              occ_num_0(i_state,1) = 0
              occ_num_0(i_state,2) = 0
            else
                if (abs(occ_numbers(i_state,1,1)-2.0d0).le.1d-6) then
                    occ_num_0(i_state,1) = 1
                    occ_num_0(i_state,2) = 1
                elseif (abs(occ_numbers(i_state,1,1)-1.0d0).le.1d-6) then
                    occ_num_0(i_state,1) = 1
                    occ_num_0(i_state,2) = 0
                endif
            endif
        enddo
    else
        do i_spin = 1, n_spin, 1
          do i_state = 1, n_states, 1
            if( occ_numbers(i_state,i_spin,1).le.1d-6 ) then
                occ_num_0(i_state,i_spin) = 0
            elseif (abs(occ_numbers(i_state,1,1)-1.0d0).le.1d-6) then
                occ_num_0(i_state,i_spin) = 1
            endif
          enddo
        enddo
        !call aims_stop('************   Spin UNrestricted calculations are not yet possible!')
    endif
    !determine the alpha and beta electron numbers
    n_elec = 0
    do i_spin = 1, 2, 1
      do i_state = 1, n_states, 1
        if (occ_num_0(i_state,i_spin).eq.1) then
            n_elec(i_spin) = n_elec(i_spin)+1
        endif
      enddo
    enddo

    if (.not.allocated(occ_num_1)) then
        allocate(occ_num_1(n_states,2), stat=errnum)
        call check_allocation(errnum, 'occ_num_1 (1D) in CI')
    endif
    occ_num_1(:,1)=1
    occ_num_1(:,2)=1

101 FORMAT(1X,E23.16,4I4)
102 FORMAT(1X,'&FCI NORB=',I3,',NELEC=',I3,',MS2=',I2,',')
!103 FORMAT(2X,'ORBSYM=',12(I1,','))
104 FORMAT(2X,'ISYM=',I1)
105 FORMAT(2X,'ISYM=',I1,' UHF=.TRUE.')
106 FORMAT(2X,'ISYM=',I1,' ROHF=.TRUE.')
    if (n_spin .eq. 1 .and. myid .eq. 0) then
        open(unit_fci,File='FCIDUMP',STATUS='NEW',FORM='FORMATTED')
        write(unit_fci,102) n_states, n_elec(1)+n_elec(2), n_elec(1)-n_elec(2)
        write(string_form,'(I3)') n_states
        string_form = "(2X,'ORBSYM=',"//trim(string_form)//"(I1,','))"
        !write(unit_fci,*) string_form
        write(unit_fci,trim(string_form)) occ_num_1(:,1)
        !write(unit_fci,103) occ_num_1(:,1)
        write(unit_fci,104) 0
        write(unit_fci,*) '&END'
    elseif (flag_single_spin_channel .and. myid .eq. 0) then
        open(unit_fci,File='FCIDUMP',STATUS='NEW',FORM='FORMATTED')
        write(unit_fci,102) n_states, n_elec(1)+n_elec(2), n_elec(1)-n_elec(2)
        write(string_form,'(I3)') n_states
        string_form = "(2X,'ORBSYM=',"//trim(string_form)//"(I1,','))"
        !write(unit_fci,*) string_form
        write(unit_fci,trim(string_form)) occ_num_1(:,1)
        !write(unit_fci,103) occ_num_1(:,1)
        write(unit_fci,106) 0
        write(unit_fci,*) '&END'
    elseif (myid .eq. 0) then
        open(unit_fci,File='FCIDUMP',STATUS='NEW',FORM='FORMATTED')
        write(unit_fci,102) n_states*2, n_elec(1)+n_elec(2), n_elec(1)-n_elec(2)
        write(string_form,'(I3)') n_states*2
        string_form = "(2X,'ORBSYM=',"//trim(string_form)//"(I1,','))"
        write(unit_fci,trim(string_form)) occ_num_1(:,:)
        write(unit_fci,105) 0
        write(unit_fci,*) '&END'
    endif
    if (n_spin .eq. 1) then
        do i_state = 1, n_states, 1
          do j_state = 1, i_state, 1
            do k_state = 1, n_states, 1
              do l_state = 1, k_state, 1
                integral_4ks_tmp = ddot(n_loc_prodbas, &
                    ovlp_3ks_local(:,l_state,k_state,1),1, &
                    ovlp_3ks_local(:,j_state,i_state,1),1)
                call sync_real_number(integral_4ks_tmp)
                if (abs(integral_4ks_tmp).gt.Threshold_Int .and. myid .eq.0) then
                    write(unit_fci,101) integral_4ks_tmp, &
                        i_state, j_state, k_state, l_state
                endif
              enddo
            enddo
          enddo
        enddo
        do i_state = 1, n_states, 1
          do j_state = 1, i_state, 1
             if (abs(integral_2ks(j_state,i_state,1)).gt.&
                 Threshold_Int .and. myid .eq.0) then
                write(unit_fci,101) integral_2ks(&
                    j_state,i_state,1&
                    ), & 
                    i_state, j_state, 0, 0
            endif
          enddo
        enddo
        !do i_state = 1, n_states, 1
        !  write(unit_fci,101) KS_eigenvalue(&
        !      i_state,1,1), & 
        !      i_state, 0,  0,  0
        !enddo
    elseif (flag_single_spin_channel) then
        do i_state = 1, n_states, 1
          do j_state = 1, i_state, 1
            do k_state = 1, n_states, 1
              do l_state = 1, k_state, 1
                integral_4ks_tmp = ddot(n_loc_prodbas, &
                    ovlp_3ks_local(:,l_state,k_state,1),1, &
                    ovlp_3ks_local(:,j_state,i_state,1),1)
                call sync_real_number(integral_4ks_tmp)
                if (abs(integral_4ks_tmp).gt.Threshold_Int .and. myid .eq.0) then
                    write(unit_fci,101) integral_4ks_tmp, &
                        i_state, j_state, k_state, l_state
                endif
              enddo
            enddo
          enddo
        enddo
        do i_state = 1, n_states, 1
          do j_state = 1, i_state, 1
             if (abs(integral_2ks(j_state,i_state,1)).gt.&
                 Threshold_Int .and. myid .eq.0) then
                write(unit_fci,101) integral_2ks(&
                    j_state,i_state,1&
                    ), & 
                    i_state, j_state, 0, 0
            endif
          enddo
        enddo
        !do i_state = 1, n_states, 1
        !  write(unit_fci,101) KS_eigenvalue(&
        !      i_state,1,1), & 
        !      i_state, 0,  0,  0
        !enddo
    else
        do i_spin = 1, n_spin, 1
          do i_state = 1, n_states, 1
            do j_state = 1, n_states, 1
              do j_spin = 1, n_spin, 1
                do k_state = 1, n_states, 1
                  do l_state = 1, n_states, 1
                    integral_4ks_tmp = ddot(n_loc_prodbas, &
                        ovlp_3ks_local(:,l_state,k_state,j_spin),1, &
                        ovlp_3ks_local(:,j_state,i_state,i_spin),1)
                    call sync_real_number(integral_4ks_tmp)
                    if (abs(integral_4ks_tmp).gt.Threshold_Int .and. myid .eq.0) then
                        write(unit_fci,101) integral_4ks_tmp, &
                            (i_state-1)*2+i_spin, &
                            (j_state-1)*2+i_spin, &
                            (k_state-1)*2+j_spin, &
                            (l_state-1)*2+j_spin
                    endif
                  enddo
                enddo
              enddo
            enddo
          enddo
        enddo
        do i_spin = 1, n_spin, 1
          do i_state = 1, n_states, 1
            do j_state = 1, i_state, 1
               if (abs(integral_2ks(j_state,i_state,i_spin)).gt.&
                   Threshold_Int .and. myid .eq.0) then
                  write(unit_fci,101) integral_2ks(&
                      j_state,i_state,i_spin), & 
                      (i_state-1)*2+i_spin, &
                      (j_state-1)*2+i_spin, &
                      0, 0
                      !i_state*2-i_spin+1, &
                      !j_state*2-i_spin+1, &
                      !0, 0
              endif
            enddo
          enddo
        enddo
        if (myid .eq. 0) then
          do i_spin = 1, n_spin, 1
            do i_state = 1, n_states, 1
              write(unit_fci,101) KS_eigenvalue(&
                  i_state,i_spin,1), & 
                  (i_state-1)*2+i_spin, &
                  0,  0, 0
                  !i_state*2-i_spin+1, &
                  !0,  0, 0
            enddo
          enddo
        endif
    endif ! store for differnt combination of spin channels
    
    if (myid .eq. 0) write(unit_fci,101) en_ion_ion, 0, 0, 0, 0

    if (myid .eq. 0) then
        close(unit_fci)
        write(use_unit,'(2X,A)') 'Two- and four-integrals have been prepared in FCIDUMP for NECI'
    endif
    call mpi_barrier(mpi_comm_global,info) ! Barrier is for correct timing!!!

end subroutine output_FCIDUMP_cluster_1d

subroutine get_2_index_integrals_1d_NECI(integral_2ks)
    ! get 2-index integrals. (i|T+V_{ext}|k)
    ! Expectation values of kinetic operator and electron-nulei interation operator
    ! Igor Ying Zhang 2013-06-12
    implicit none
    real*8, dimension(:,:,:), intent(out) :: integral_2ks
    
    !real*8  :: ddot
    ! temp variables
    integer :: errnum, occ_states, unocc_states
    integer :: i_state, j_state, k_state, l_state
    integer :: i_spin, j_spin
    real*8, dimension(:,:), allocatable :: tmp_matrix
    real*8  :: T_Vext, Vhartree, E_noXC
    real*8  :: ddot

    !------------------------------------------------------------
    ! calculate the hamiltonian matrix with only hatree potential
    !------------------------------------------------------------
    ! calculate the matrix of (i|T+V_{ext}+V_{Hartree}|j)
    flag_xc               = 0
    hybrid_coeff          = 0.0d0
    flag_turn_off_hartree = .true.
    integral_2ks(:,:,:)   = 0.d0

    call integrate_real_hamiltonian_matrix_p2 &
       ( hartree_potential,   rho, rho_gradient, partition_tab, l_shell_max, &
       en_xc, en_pot_xc, hamiltonian )

    if(n_spin==1) then
      ! transfer the hamiltonian in the Kohn-Sham orbital representation
      do i_state = 1, n_basis, 1
        do j_state = 1, i_state, 1
            integral_2ks(j_state,i_state,1) = &
                hamiltonian(j_state + ((i_state-1)*i_state)/2,1)
        enddo
      enddo
      if (.not.allocated(tmp_matrix)) then
          allocate(tmp_matrix(n_basis,n_basis), stat=errnum)
          call check_allocation(errnum, 'tmp_matrix (1D) in FCIQMC')
      endif
      tmp_matrix(:,:) = 0.d0
      call dsymm('L', 'U', n_basis, &
                 n_states, 1.0d0, &
                 integral_2ks(:,:,1), n_basis, &
                 KS_eigenvector(:,:,1,1), &
                 n_basis, 0.d0, &
                 tmp_matrix, &
                 n_basis &
                 )

      integral_2ks(:,:,1) = 0.d0
      call dgemm('T', 'N', n_states, &
                  n_states, n_basis, 1.0d0, &
                  tmp_matrix, &
                  n_basis, &
                  KS_eigenvector(:,:,1,1), &
                  n_basis, 0.d0, &
                  integral_2ks(:,:,1), &
                  n_states &
                  )
      deallocate(tmp_matrix)
    ! Now for n_spin == 2
    else
      ! transfer the hamiltonian in the Kohn-Sham orbital representation
      if (.not.allocated(tmp_matrix)) then
          allocate(tmp_matrix(n_basis,n_basis), stat=errnum)
          call check_allocation(errnum, 'tmp_matrix (1D) in FCIQMC')
      endif
      do i_spin = 1, n_spin, 1
        tmp_matrix(:,:) = 0.d0
        do i_state = 1, n_basis, 1
          do j_state = 1, i_state, 1
              integral_2ks(j_state,i_state,i_spin) = &
                  hamiltonian(j_state + ((i_state-1)*i_state)/2,i_spin)
          enddo
        enddo
        call dsymm('L', 'U', n_basis, &
                   n_states, 1.0d0, &
                   integral_2ks(:,:,i_spin), n_basis, &
                   KS_eigenvector(:,:,i_spin,1), &
                   n_basis, 0.d0, &
                   tmp_matrix, &
                   n_basis &
                   )

        integral_2ks(:,:,i_spin) = 0.d0
        call dgemm('T', 'N', n_states, &
                    n_states, n_basis, 1.0d0, &
                    tmp_matrix, &
                    n_basis, &
                    KS_eigenvector(:,:,i_spin,1), &
                    n_basis, 0.d0, &
                    integral_2ks(:,:,i_spin), &
                    n_states &
                    )
      enddo
      deallocate(tmp_matrix)
    endif
end subroutine get_2_index_integrals_1d_NECI


subroutine cleanup_ci ()
    implicit none
     if (allocated(integral_4ks)) then
       deallocate(integral_4ks)
     end if
     if (allocated(integral_2ks)) then
       deallocate(integral_2ks)
     end if
     if (allocated(ovlp_3ks)) then
       deallocate(ovlp_3ks)
     end if
     if (allocated(c_vect)) then
       deallocate(c_vect)
     end if
end subroutine cleanup_ci



  Subroutine ci_acc_save_wvfn(i_ci_acc)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Save the wave-function     (cvect)           !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  Integer :: i_ci_acc,j_ci_acc

  ci_acc_save_c0(i_ci_acc) = c_0
  do j_ci_acc = 1, n_configuration_table(myid+1)
    ci_acc_save_cvect(i_ci_acc,j_ci_acc) = c_vect(j_ci_acc)
  end do

  End Subroutine ci_acc_save_wvfn



  Subroutine ci_acc_save_itgl(i_ci_acc)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Save the integral matrix w (wvect)           !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  Integer :: i_ci_acc,j_ci_acc

  ci_acc_save_w0(i_ci_acc) = w_0
  do j_ci_acc = 1, n_configuration_table(myid+1)
    ci_acc_save_wvect(i_ci_acc,j_ci_acc) = w_vect(j_ci_acc)
  end do

  End Subroutine ci_acc_save_itgl



end module fciqmc_module
