!****s* FHI-aims/get_fixed_basis_fns
!  NAME
!   get_fixed_basis_fns
!  SYNOPSIS

 subroutine get_fixed_basis_fns ( )

!  PURPOSE
!  Subroutine get_fixed_basis_fns integrates Schroedinger equation to provide
!  the atomic-like basis part for the current effective potential
!
!  USES
      use dimensions,      only : n_max_ind_fns, n_max_grid, n_species, use_sph_gaussian
      use runtime_choices, only : hydro_cut, out_basis, flag_rel, REL_x2c, REL_4c_dks
      use species_data,    only : ionic_eigenval, confined_eigenval, confined_pot, confined_wave, &
                                  hydro_wave, hydro_wave_large, hydro_wave_small, hydro_kinetic, &
                                  n_hydro, hydro_n, hydro_l, gaussian_n, gaussian_l, gaussian_wave, &
                                  gaussian_kinetic, ionic_pot, ionic_wave, species_pseudoized, &
                                  n_ionic, species_name, ionic_n, ionic_l, n_conf, conf_n, n_atomic, &
                                  atomic_n, conf_l, atomic_l, n_gaussian, n_sto
      use grids,           only : n_grid, r_grid
      use free_atoms,      only : free_wave_eigenval
      use localorb_io,     only : use_unit, localorb_info
      use mpi_tasks,       only : myid
      implicit none
!  INPUT
!   none
!  OUTPUT
!   none
!  AUTHOR
!    FHI-aims team, Fritz-Haber Institute of the Max-Planck-Society
!  SEE ALSO
!    Volker Blum, Ralf Gehrke, Felix Hanke, Paula Havu, Ville Havu,
!    Xinguo Ren, Karsten Reuter, and Matthias Scheffler,
!    "Ab initio simulations with Numeric Atom-Centered Orbitals: FHI-aims",
!    Computer Physics Communications (2008), submitted.
!  COPYRIGHT
!   Max-Planck-Gesellschaft zur Foerderung der Wissenschaften
!   e.V. Please note that any use of the "FHI-aims-Software" is subject to
!   the terms and conditions of the respective license agreement."
!  HISTORY
!    Release version, FHI-aims (2008).
!  SOURCE
!  constants


!  imported variables

!     input
!     output - see module species_data.f

!  local variables

!  free_ion_pot: s.-c. Kohn-Sham potential of free ion, from get_free_ion
!  free_ion_wave: s.-c. Kohn-Sham wave functions of free ion, from get_free_ion
!  free_ion_eigenval: s.-c. Kohn-Sham eigenvalues of free ion, from get_free_ion

      integer n_free_ionic
      real*8 free_ion_pot(n_max_grid)
      real*8 free_ion_wave(n_max_grid, n_max_ind_fns)
      real*8 free_ion_wave_deriv(n_max_grid, n_max_ind_fns)
      real*8 free_ion_eigenval(n_max_ind_fns)
      real*8 free_ion_kinetic(n_max_grid, n_max_ind_fns)
      integer free_ion_n(n_max_ind_fns)
      integer free_ion_l(n_max_ind_fns)

      logical found
      integer i_same_fn

!  counters

      integer i_species, i_grid, i_fn
      integer i_ionic, i_conf

!  functions

!  debug

      character*4 descript

!  begin work

!      write(use_unit,'(2X,A,A)') "Creating fixed part of basis set: Ionic,",
!     +            " confined, hydrogenic."

      call localorb_info( &
       "Creating fixed part of basis set: Ionic, confined, hydrogenic.", &
           use_unit,'(2X,A)')

      do i_species = 1, n_species, 1
      if(species_pseudoized(i_species)) cycle
!       ionic wave functions
        if (n_ionic(i_species).gt.0) then

           if (myid.eq.0) then
              write(use_unit,*)
              write(use_unit,'(2X,A,A)')&
                 species_name(i_species), " ion:"
           end if

!         get free ionic potential
!         (wave fn and eigenvalues are nice but not necessary later)
!         WPH:  To elaborate on this, the ionic wavefunctions that are generated by this 
!         subroutine will be discarded later. They are here for comparison/output purposes only.
!         The ionic basis functions that appear in aims  
!         calculations are instead generated by integrating free_ion_pot (which is 
!         needed) via dftseq in the subroutine get_ionic_basis_fns.
!         Unlike the free atom case (get_free_atom), where this re-calculation is not 
!         necessary and can be avoided by storing the wavefunctions, here it is truly 
!         necessary because, unlike the minimal/atomic basis elements which always 
!         corresponds to occupied states that will be calculated, the ionic basis 
!         elements may be unoccupied states which are not calculated by this function.
          call get_free_ion &
          ( i_species, &
            free_ion_pot, n_free_ionic, free_ion_wave, free_ion_wave_deriv, &
            free_ion_eigenval, free_ion_kinetic, free_ion_n, free_ion_l &
          )

!         calculate ionic basis functions
!         (occupied and unoccupied, including cutoff potential)
          do i_ionic = 1, n_ionic(i_species), 1
            found = .false.
            do i_fn = 1, n_free_ionic, 1
              if ( (free_ion_l(i_fn).eq.ionic_l(i_species,i_ionic)) &
                   .and. &
                   (free_ion_n(i_fn).eq.ionic_n(i_species,i_ionic)) &
                 ) then
                 found = .true.
                 i_same_fn = i_fn
              end if
            enddo
            if (found) then
!             if we are recalculating an occupied state (n,l), then
!             use the free ionic eigenvalue to initialize the basis eigenvalue
              ionic_eigenval(i_species, i_ionic) = &
              free_ion_eigenval(i_same_fn)
            else
              ionic_eigenval(i_species, i_ionic) = 0.d0
            end if
          enddo


         call get_ionic_basis_fns ( i_species, free_ion_pot )

          if (out_basis) then
!           output the raw ionic eigenfunctions
            descript='base'
            call ion_out &
            ( i_species, n_grid(i_species), n_ionic, ionic_n, ionic_l, &
              r_grid(1,i_species), &
              ionic_pot, ionic_wave, ionic_eigenval, &
              descript, n_species, n_max_grid, n_max_ind_fns &
            )
          end if

        end if



!       confined free-atom wave functions
        if (n_conf(i_species).gt.0) then

           if (myid.eq.0) then
              write(use_unit,*)
              write(use_unit,'(2X,A,A)')&
                 species_name(i_species), " confined:"
           end if

!         calculate confined basis functions
!         (including cutoff potential)
          do i_conf = 1, n_conf(i_species), 1
            found = .false.
            do i_fn = 1, n_atomic(i_species), 1
              if &
              ( (atomic_l(i_species,i_fn).eq.conf_l(i_species,i_conf)) &
                .and. &
                (atomic_n(i_species,i_fn).eq.conf_n(i_species,i_conf)) &
              ) then
                found = .true.
                i_same_fn = i_fn
              end if
            enddo

            if (found) then
!             if we are recalculating an occupied state (n,l), then
!             use the free atom eigenvalue to initialize the basis eigenvalue
              confined_eigenval(i_species, i_conf) = &
              free_wave_eigenval(i_species, i_same_fn)
            else
              confined_eigenval(i_species, i_conf) = 0.d0
            end if
          enddo

          call get_confined_basis_fns ( i_species )

          if (out_basis) then
!           output the raw confined eigenfunctions
            descript='base'
            call confined_out &
            ( i_species, n_grid(i_species), n_conf, conf_n, conf_l, &
              r_grid(1,i_species), &
              confined_pot, confined_wave, confined_eigenval, &
              descript, n_species, n_max_grid, n_max_ind_fns &
            )
          end if

        end if

!       hydrogenic wave functions
        if (n_hydro(i_species).gt.0) then

           if (myid.eq.0) then
              write(use_unit,*)
              write(use_unit,'(2X,A,A)') species_name(i_species), " hydrogenic:"
           end if

!         calculate hydrogenic basis functions

          if (.not.hydro_cut) then

!           no cutoff potential - analytic version
            if(flag_rel.eq.REL_x2c .or. flag_rel.eq.REL_4c_dks)then
              write(use_unit,*)'Error in get_fixed_basis_fns: cutoff for hydrogenic basis is needed for relativistic cases currently!'
              stop
              call get_dirac_hydrogenic_basis_fns( i_species ) ! relativistic
            else
              call get_hydrogenic_basis_fns( i_species ) ! non-relativistic
            endif

          else

!           cutoff potential added - numeric version
            if(flag_rel.eq.REL_x2c .or. flag_rel.eq.REL_4c_dks)then
              call int_dirac_hydrogenic_basis_fns( i_species ) ! relativistic
            else
              call int_hydrogenic_basis_fns( i_species ) ! non-relativistic
            endif

          end if

          if (out_basis) then
!           output the raw hydrogenic eigenfunctions
            if(flag_rel.eq.REL_x2c .or. flag_rel.eq.REL_4c_dks)then
              descript='dirac-hydro'
              ! (Rundong) Need to be debugged.
              call hydrogenic_out ( i_species, n_grid(i_species), n_hydro, hydro_n, hydro_l, &
                r_grid(1,i_species), hydro_wave_large, hydro_kinetic, descript, n_species, n_max_grid, n_max_ind_fns)
            else
              descript='base'
              call hydrogenic_out ( i_species, n_grid(i_species), n_hydro, hydro_n, hydro_l, &
                r_grid(1,i_species), hydro_wave, hydro_kinetic, descript, n_species, n_max_grid, n_max_ind_fns )
            endif
          end if

        end if

!       cartesian Gaussian wave functions
        if (n_gaussian(i_species).gt.0) then

           if (myid.eq.0) then
              write(use_unit,*)
              write(use_unit,'(2X,A,A)')&
                 species_name(i_species), " Gaussian:"
           end if

!         calculate Gaussian radial functions

!         no cutoff potential - analytic version
          if (use_sph_gaussian) then
            call get_sph_gaussian_basis_fns( i_species )
          else
            call get_gaussian_basis_fns ( i_species )
          endif

          if (out_basis) then
!           output the raw Gaussian radial functions
            descript='base'
            call gaussian_out &
            ( i_species, n_grid(i_species), n_gaussian, &
              gaussian_n, gaussian_l, &
              r_grid(1,i_species), gaussian_wave, gaussian_kinetic, &
              descript, n_species, n_max_grid, n_max_ind_fns &
            )
          end if

        end if

        if (n_sto(i_species) > 0) call get_sto_basis_fns(i_species)

      enddo

      return
 end subroutine get_fixed_basis_fns
!******
